<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Try Partial Lenses with KLIPSE</title>
    <link rel="icon" href="https://avatars1.githubusercontent.com/u/17234211">
    <link rel="stylesheet" type="text/css" href="github.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/googlecode.min.css">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script type="text/javascript">startTime = Date.now()</script>
    <script type="text/javascript" src="start.js" async></script>
  </head>
  <body class="markdown-body">
    <div class="loading-message">
      Please wait... The interactive code snippets on this page take a moment to load.
    </div>
    <div class="menu">
      <div class="menu-overlay"></div>
      <div class="menu-body">
        <div class="hamburger">≡</div>
        <div class="menu-contents"></div>
      </div>
    </div>
    <p>
      All the code snippets on this page are <b>live</b> and <b>interactive</b>
      powered by the <a href="https://github.com/viebel/klipse">klipse
      plugin</a>.
    <p>
    <hr>
    <h1 id="-a-id-partial-lenses-a-partial-lenses-middot-gitter-https-img-shields-io-gitter-room-calmm-js-chat-js-svg-https-gitter-im-calmm-js-chat-github-stars-https-img-shields-io-github-stars-calmm-js-partial-lenses-svg-style-social-https-github-com-calmm-js-partial-lenses-"><a id="partial.lenses"></a> Partial Lenses &middot; <a href="https://gitter.im/calmm-js/chat"><img src="https://img.shields.io/gitter/room/calmm-js/chat.js.svg" alt="Gitter"></a> <a href="https://github.com/calmm-js/partial.lenses"><img src="https://img.shields.io/github/stars/calmm-js/partial.lenses.svg?style=social" alt="GitHub stars"></a></h1>
<p>Lenses are basically an abstraction for simultaneously specifying operations
to <a href="#L-modify">update</a> and <a href="#L-get">query</a> immutable data structures.  Lenses
are <a href="#on-composability">highly composable</a> and can be <a href="#benchmarks">efficient</a>.
This library provides a collection
of <a href="#on-partiality">partial</a> <a href="#isomorphisms">isomorphisms</a>, <a href="#lenses">lenses</a>,
and <a href="#traversals">traversals</a>, collectively known as <a href="#optics">optics</a>, for
manipulating <a href="http://json.org/">JSON</a> and
users <a href="#L-toFunction">can</a> <a href="#L-iso">write</a> <a href="#L-lens">new</a> <a href="#L-branch">optics</a>
for manipulating non-JSON objects, such as <a href="#interfacing">Immutable.js</a>
collections.  A partial lens can <em>view</em> optional data, <em>insert</em> new data,
<em>update</em> existing data and <em>remove</em> existing data and can, for example, provide
<em>defaults</em> and maintain <em>required</em> data structure
parts.  <a href="https://calmm-js.github.io/partial.lenses/">▶ Try Lenses!</a></p>
<p><a href="http://badge.fury.io/js/partial.lenses"><img src="https://badge.fury.io/js/partial.lenses.svg" alt="npm version"></a>
<a href="https://badge.fury.io/bo/partial.lenses"><img src="https://badge.fury.io/bo/partial.lenses.svg" alt="Bower version"></a>
<a href="https://travis-ci.org/calmm-js/partial.lenses"><img src="https://travis-ci.org/calmm-js/partial.lenses.svg?branch=master" alt="Build Status"></a>
<a href="https://codecov.io/github/calmm-js/partial.lenses?branch=master"><img src="https://img.shields.io/codecov/c/github/calmm-js/partial.lenses/master.svg" alt="Code Coverage"></a>
<a href="https://david-dm.org/calmm-js/partial.lenses"><img src="https://david-dm.org/calmm-js/partial.lenses.svg" alt=""></a>
<a href="https://david-dm.org/calmm-js/partial.lenses?type=dev"><img src="https://david-dm.org/calmm-js/partial.lenses/dev-status.svg" alt=""></a></p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#optics">Optics</a><ul>
<li><a href="#on-partiality">On partiality</a></li>
<li><a href="#on-composability">On composability</a></li>
<li><a href="#operations-on-optics">Operations on optics</a><ul>
<li><a href="#L-modify" title="L.modify: POptic s a -&gt; ((Maybe a, Index) -&gt; Maybe a) -&gt; Maybe s -&gt; Maybe s"><code>L.modify(optic, (maybeValue, index) =&gt; maybeValue, maybeData) ~&gt; maybeData</code></a></li>
<li><a href="#L-remove" title="L.remove: POptic s a -&gt; Maybe s -&gt; Maybe s"><code>L.remove(optic, maybeData) ~&gt; maybeData</code></a></li>
<li><a href="#L-set" title="L.set: POptic s a -&gt; Maybe a -&gt; Maybe s -&gt; Maybe s"><code>L.set(optic, maybeValue, maybeData) ~&gt; maybeData</code></a></li>
</ul>
</li>
<li><a href="#nesting">Nesting</a><ul>
<li><a href="#L-compose" title="L.compose: (POptic s s1, ...POptic sN a) -&gt; POptic s a"><code>L.compose(...optics) ~&gt; optic</code></a> or <code>[...optics]</code></li>
</ul>
</li>
<li><a href="#querying">Querying</a><ul>
<li><a href="#L-chain" title="L.chain: ((a, Index) -&gt; POptic s b) -&gt; POptic s a -&gt; POptic s b"><code>L.chain((value, index) =&gt; optic, optic) ~&gt; optic</code></a></li>
<li><a href="#L-choice" title="L.choice: (...PLens s a) -&gt; POptic s a"><code>L.choice(...lenses) ~&gt; optic</code></a></li>
<li><a href="#L-choose" title="L.choose: ((Maybe s, Index) -&gt; POptic s a) -&gt; POptic s a"><code>L.choose((maybeValue, index) =&gt; optic) ~&gt; optic</code></a></li>
<li><a href="#L-optional" title="L.optional: POptic a a"><code>L.optional ~&gt; optic</code></a></li>
<li><a href="#L-when" title="L.when: ((Maybe a, Index) -&gt; Boolean) -&gt; POptic a a"><code>L.when((maybeValue, index) =&gt; testable) ~&gt; optic</code></a></li>
<li><a href="#L-zero" title="L.zero: POptic s a"><code>L.zero ~&gt; optic</code></a></li>
</ul>
</li>
<li><a href="#recursing">Recursing</a><ul>
<li><a href="#L-lazy" title="L.lazy: (POptic s a -&gt; POptic s a) -&gt; POptic s a"><code>L.lazy(optic =&gt; optic) ~&gt; optic</code></a></li>
</ul>
</li>
<li><a href="#debugging">Debugging</a><ul>
<li><a href="#L-log" title="L.log: (...Any) -&gt; POptic s s"><code>L.log(...labels) ~&gt; optic</code></a></li>
</ul>
</li>
<li><a href="#internals">Internals</a><ul>
<li><a href="#L-toFunction" title="L.toFunction: POptic s a -&gt; ((Functor|Applicative) c, (Maybe a, Index) -&gt; c b, Maybe s, Index) -&gt; c t"><code>L.toFunction(optic) ~&gt; optic</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#transforms">Transforms</a><ul>
<li><a href="#sequencing">Sequencing</a><ul>
<li><a href="#L-seq" title="L.seq: (...POptic s a) -&gt; PTransform s a"><code>L.seq(...optics) ~&gt; transform</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#traversals">Traversals</a><ul>
<li><a href="#operations-on-traversals">Operations on traversals</a><ul>
<li><a href="#L-concat" title="L.concat: Monoid a -&gt; (PTraversal s a -&gt; Maybe s -&gt; a)"><code>L.concat(monoid, traversal, maybeData) ~&gt; value</code></a></li>
<li><a href="#L-concatAs" title="L.concatAs: ((Maybe a, Index) -&gt; r) -&gt; Monoid r -&gt; (PTraversal s a -&gt; Maybe s -&gt; r)"><code>L.concatAs((maybeValue, index) =&gt; value, monoid, traversal, maybeData) ~&gt; value</code></a></li>
<li><del><a href="#L-merge" title="L.merge: Monoid a -&gt; (PTraversal s a -&gt; Maybe s -&gt; a)"><code>L.merge(monoid, traversal, maybeData) ~&gt; value</code></a></del></li>
<li><del><a href="#L-mergeAs" title="L.mergeAs: ((Maybe a, Index) -&gt; r) -&gt; Monoid r -&gt; (PTraversal s a -&gt; Maybe s -&gt; r)"><code>L.mergeAs((maybeValue, index) =&gt; value, monoid, traversal, maybeData) ~&gt; value</code></a></del></li>
</ul>
</li>
<li><a href="#folds-over-traversals">Folds over traversals</a><ul>
<li><a href="#L-all" title="L.all: ((Maybe a, Index) -&gt; Boolean) -&gt; PTraversal s a -&gt; Boolean"><code>L.all((maybeValue, index) =&gt; testable, traversal, maybeData) ~&gt; boolean</code></a></li>
<li><a href="#L-and" title="L.or: PTraversal s Boolean -&gt; Boolean"><code>L.and(traversal, maybeData) ~&gt; boolean</code></a></li>
<li><a href="#L-any" title="L.any: ((Maybe a, Index) -&gt; Boolean) -&gt; PTraversal s a -&gt; Boolean"><code>L.any((maybeValue, index) =&gt; testable, traversal, maybeData) ~&gt; boolean</code></a></li>
<li><a href="#L-collect" title="L.collect: PTraversal s a -&gt; Maybe s -&gt; [a]"><code>L.collect(traversal, maybeData) ~&gt; [...values]</code></a></li>
<li><a href="#L-collectAs" title="L.collectAs: ((Maybe a, Index) -&gt; Maybe b) -&gt; PTraversal s a -&gt; Maybe s -&gt; [b]"><code>L.collectAs((maybeValue, index) =&gt; maybeValue, traversal, maybeData) ~&gt; [...values]</code></a></li>
<li><a href="#L-first" title="L.first: PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.first(traversal, maybeData) ~&gt; maybeValue</code></a></li>
<li><a href="#L-firstAs" title="L.firstAs: ((Maybe a, Index) -&gt; Maybe b) -&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe b"><code>L.firstAs((maybeValue, index) =&gt; maybeValue, traversal, maybeData) ~&gt; maybeValue</code></a></li>
<li><a href="#L-foldl" title="L.foldl: ((r, Maybe a, Index) -&gt; r) -&gt; r -&gt; PTraversal s a -&gt; Maybe s -&gt; r"><code>L.foldl((value, maybeValue, index) =&gt; value, value, traversal, maybeData) ~&gt; value</code></a></li>
<li><a href="#L-foldr" title="L.foldr: ((r, Maybe a, Index) -&gt; r) -&gt; r -&gt; PTraversal s a -&gt; Maybe s -&gt; r"><code>L.foldr((value, maybeValue, index) =&gt; value, value, traversal, maybeData) ~&gt; value</code></a></li>
<li><a href="#L-maximum" title="L.maximum: Ord a =&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.maximum(traversal, maybeData) ~&gt; maybeValue</code></a></li>
<li><a href="#L-minimum" title="L.minimum: Ord a =&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.minimum(traversal, maybeData) ~&gt; maybeValue</code></a></li>
<li><a href="#L-or" title="L.or: PTraversal s Boolean -&gt; Boolean"><code>L.or(traversal, maybeData) ~&gt; boolean</code></a></li>
<li><a href="#L-product" title="L.product: PTraversal s Number -&gt; Maybe s -&gt; Number"><code>L.product(traversal, maybeData) ~&gt; number</code></a></li>
<li><a href="#L-sum" title="L.sum: PTraversal s Number -&gt; Maybe s -&gt; Number"><code>L.sum(traversal, maybeData) ~&gt; number</code></a></li>
</ul>
</li>
<li><a href="#creating-new-traversals">Creating new traversals</a><ul>
<li><a href="#L-branch" title="L.branch: {p1: PTraversal s a, ...pts} -&gt; PTraversal s a"><code>L.branch({prop: traversal, ...props}) ~&gt; traversal</code></a></li>
</ul>
</li>
<li><a href="#traversals-and-combinators">Traversals and combinators</a><ul>
<li><a href="#L-elems" title="L.elems: PTraversal [a] a"><code>L.elems ~&gt; traversal</code></a></li>
<li><a href="#L-values" title="L.values: PTraversal {p: a, ...ps} a"><code>L.values ~&gt; traversal</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lenses">Lenses</a><ul>
<li><a href="#operations-on-lenses">Operations on lenses</a><ul>
<li><a href="#L-get" title="L.get: PLens s a -&gt; Maybe s -&gt; Maybe a"><code>L.get(lens, maybeData) ~&gt; maybeValue</code></a></li>
</ul>
</li>
<li><a href="#creating-new-lenses">Creating new lenses</a><ul>
<li><a href="#L-lens" title="L.lens: ((Maybe s, Index) -&gt; Maybe a) -&gt; ((Maybe a, Maybe s, Index) -&gt; Maybe s) -&gt; PLens s a"><code>L.lens((maybeData, index) =&gt; maybeValue, (maybeValue, maybeData, index) =&gt; maybeData) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#computing-derived-props">Computing derived props</a><ul>
<li><a href="#L-augment" title="L.augment: {p1: o -&gt; a1, ...ps} -&gt; PLens {...o} {...o, p1: a1, ...ps}"><code>L.augment({prop: object =&gt; value, ...props}) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#enforcing-invariants">Enforcing invariants</a><ul>
<li><a href="#L-defaults" title="L.defaults: s -&gt; PLens s s"><code>L.defaults(valueIn) ~&gt; lens</code></a></li>
<li><a href="#L-define" title="L.define: s -&gt; PLens s s"><code>L.define(value) ~&gt; lens</code></a></li>
<li><a href="#L-normalize" title="L.normalize: ((s, Index) -&gt; Maybe s) -&gt; PLens s s"><code>L.normalize((value, index) =&gt; maybeValue) ~&gt; lens</code></a></li>
<li><a href="#L-required" title="L.required: s -&gt; PLens s s"><code>L.required(valueOut) ~&gt; lens</code></a></li>
<li><a href="#L-rewrite" title="L.rewrite: ((s, Index) -&gt; Maybe s) -&gt; PLens s s"><code>L.rewrite((valueOut, index) =&gt; maybeValueOut) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#array-like">Lensing array-like objects</a><ul>
<li><a href="#L-append" title="L.append: PLens [a] a"><code>L.append ~&gt; lens</code></a></li>
<li><a href="#L-filter" title="L.filter: ((a, Index) -&gt; Boolean) -&gt; PLens [a] [a]"><code>L.filter((value, index) =&gt; testable) ~&gt; lens</code></a></li>
<li><a href="#L-find" title="L.find: ((a, Index) -&gt; Boolean) -&gt; PLens [a] a"><code>L.find((value, index) =&gt; testable) ~&gt; lens</code></a></li>
<li><a href="#L-findWith" title="L.findWith: (PLens s s1, ...PLens sN a) -&gt; PLens [s] a"><code>L.findWith(...lenses) ~&gt; lens</code></a></li>
<li><a href="#L-index" title="L.index: Integer -&gt; PLens [a] a"><code>L.index(elemIndex) ~&gt; lens</code></a> or <code>elemIndex</code></li>
<li><a href="#L-slice" title="L.slice: Maybe Integer -&gt; Maybe Integer -&gt; PLens [a] [a]"><code>L.slice(maybeBegin, maybeEnd) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#lensing-objects">Lensing objects</a><ul>
<li><a href="#L-prop" title="L.prop: (p: a) -&gt; PLens {p: a, ...ps} a"><code>L.prop(propName) ~&gt; lens</code></a> or <code>propName</code></li>
<li><a href="#L-props" title="L.props: (p1: a1, ...ps) -&gt; PLens {p1: a1, ...ps, ...o} {p1: a1, ...ps}"><code>L.props(...propNames) ~&gt; lens</code></a></li>
<li><a href="#L-removable" title="L.removable (p1: a1, ...ps) -&gt; PLens {p1: a1, ...ps, ...o} {p1: a1, ...ps, ...o}"><code>L.removable(...propNames) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#providing-defaults">Providing defaults</a><ul>
<li><a href="#L-valueOr" title="L.valueOr: s -&gt; PLens s s"><code>L.valueOr(valueOut) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#adapting-to-data">Adapting to data</a><ul>
<li><a href="#L-orElse" title="L.orElse: (PLens s a, PLens s a) -&gt; PLens s a"><code>L.orElse(backupLens, primaryLens) ~&gt; lens</code></a></li>
</ul>
</li>
<li><a href="#read-only-mapping">Read-only mapping</a><ul>
<li><del><a href="#L-just" title="L.just: Maybe a -&gt; PLens s a"><code>L.just(maybeValue) ~&gt; lens</code></a></del></li>
<li><del><a href="#L-to" title="L.to: ((a, Index) -&gt; b) -&gt; PLens a b"><code>L.to((maybeValue, index) =&gt; maybeValue) ~&gt; lens</code></a></del></li>
</ul>
</li>
<li><a href="#transforming-data">Transforming data</a><ul>
<li><a href="#L-pick" title="L.pick: {p1: PLens s a1, ...pls} -&gt; PLens s {p1: a1, ...pls}"><code>L.pick({prop: lens, ...props}) ~&gt; lens</code></a></li>
<li><a href="#L-replace" title="L.replace: Maybe s -&gt; Maybe s -&gt; PLens s s"><code>L.replace(maybeValueIn, maybeValueOut) ~&gt; lens</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#isomorphisms">Isomorphisms</a><ul>
<li><a href="#operations-on-isomorphisms">Operations on isomorphisms</a><ul>
<li><a href="#L-getInverse" title="L.getInverse: PIso a b -&gt; Maybe b -&gt; Maybe a"><code>L.getInverse(isomorphism, maybeData) ~&gt; maybeData</code></a></li>
</ul>
</li>
<li><a href="#creating-new-isomorphisms">Creating new isomorphisms</a><ul>
<li><a href="#L-iso" title="L.iso: (Maybe s -&gt; Maybe a) -&gt; (Maybe a -&gt; Maybe s) -&gt; PIso s a"><code>L.iso(maybeData =&gt; maybeValue, maybeValue =&gt; maybeData) ~&gt; isomorphism</code></a></li>
</ul>
</li>
<li><a href="#isomorphisms-and-combinators">Isomorphisms and combinators</a><ul>
<li><a href="#L-identity" title="L.identity: PIso s s"><code>L.identity ~&gt; isomorphism</code></a></li>
<li><a href="#L-inverse" title="L.inverse: PIso a b -&gt; PIso b a"><code>L.inverse(isomorphism) ~&gt; isomorphism</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#an-array-of-ids-as-boolean-flags">An array of ids as boolean flags</a></li>
<li><a href="#bst-as-a-lens">BST as a lens</a></li>
<li><a href="#interfacing">Interfacing with Immutable.js</a></li>
</ul>
</li>
<li><a href="#background">Background</a><ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#design-choices">Design choices</a></li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#lenses-all-the-way">Lenses all the way</a></li>
<li><a href="#related-work">Related work</a></li>
</ul>
</li>
</ul>
<h2 id="tutorial">Tutorial</h2>
<p>Let&#39;s work with the following sample JSON object:</p>
<pre><code class="hljs lang-js">var sampleTitles = {
  titles: [{ language: &quot;en&quot;, text: &quot;Title&quot; },
           { language: &quot;sv&quot;, text: &quot;Rubrik&quot; }]
}
</code></pre>
<p>What we&#39;d like to have is a way to access the <code>text</code> of titles in a given
language.  Given a language, we want to be able to</p>
<ul>
<li>get the corresponding text,</li>
<li>update the corresponding text,</li>
<li>insert a new text and the immediately surrounding object in a new language, and</li>
<li>remove an existing text and the immediately surrounding object.</li>
</ul>
<p>Furthermore, when updating, inserting, and removing texts, we&#39;d like the
operations to treat the JSON as immutable and create new JSON objects with the
changes rather than mutate existing JSON objects.</p>
<p>Operations like these are what lenses are good at.  Lenses can be seen as a
simple embedded <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>
for specifying data manipulation and querying functions.  Lenses allow you to
focus on an element in a data structure by specifying a path from the root of
the data structure to the desired element.  Given a lens, one can then perform
operations, like <a href="#L-get"><code>get</code></a> and <a href="#L-set"><code>set</code></a>, on the element that the
lens focuses on.</p>
<h3 id="getting-started">Getting started</h3>
<p>Let&#39;s first import the libraries</p>
<pre><code class="hljs lang-jsx">import * as L from &quot;partial.lenses&quot;
import * as R from &quot;ramda&quot;
</code></pre>
<p>and <a href="https://calmm-js.github.io/partial.lenses#getting-started">▶ play</a> just a
bit with lenses.</p>
<blockquote>
<p>Note that links with the play
symbol, <a href="https://calmm-js.github.io/partial.lenses#getting-started">▶</a>, take
you to an interactive version of this page where almost all of the code
snippets are editable and evaluated in the browser.  Note that due to the
large number of snippets the interactive version of this page takes awhile to
render.</p>
</blockquote>
<p>As mentioned earlier, with lenses we can specify a path to focus on an element.
To specify such a path we use primitive lenses
like <a href="#L-prop"><code>L.prop(propName)</code></a>, to access a named property of an object,
and <a href="#L-index"><code>L.index(elemIndex)</code></a>, to access an element at a given index in
an array, and compose the path using <a href="#L-compose"><code>L.compose(...lenses)</code></a>.</p>
<p>So, to just <a href="#L-get">get</a> at the <code>titles</code> array of the <code>sampleTitles</code> we can use
the lens <a href="#L-prop"><code>L.prop(&quot;titles&quot;)</code></a>:</p>
<pre><code class="hljs lang-js">L.get(L.prop(&quot;titles&quot;),
      sampleTitles)
</code></pre>
<p>To focus on the first element of the <code>titles</code> array, we compose with
the <a href="#L-index"><code>L.index(0)</code></a> lens:</p>
<pre><code class="hljs lang-js">L.get(L.compose(L.prop(&quot;titles&quot;),
                L.index(0)),
      sampleTitles)
</code></pre>
<p>Then, to focus on the <code>text</code>, we compose with <a href="#L-prop"><code>L.prop(&quot;text&quot;)</code></a>:</p>
<pre><code class="hljs lang-js">L.get(L.compose(L.prop(&quot;titles&quot;),
                L.index(0),
                L.prop(&quot;text&quot;)),
      sampleTitles)
</code></pre>
<p>We can then use the same composed lens to also <a href="#L-set">set</a> the <code>text</code>:</p>
<pre><code class="hljs lang-js">L.set(L.compose(L.prop(&quot;titles&quot;),
                L.index(0),
                L.prop(&quot;text&quot;)),
      &quot;New title&quot;,
      sampleTitles)
</code></pre>
<p>In practise, specifying ad hoc lenses like this is not very useful.  We&#39;d like
to access a text in a given language, so we want a lens parameterized by a given
language.  To create a parameterized lens, we can write a function that returns
a lens.  Such a lens should then <a href="#L-find">find</a> the title in the desired
language.</p>
<p>Furthermore, while a simple path lens like above allows one to get and set an
existing text, it doesn&#39;t know enough about the data structure to be able to
properly insert new and remove existing texts.  So, we will also need to specify
such details along with the path to focus on.</p>
<h3 id="a-partial-lens-to-access-title-texts">A partial lens to access title texts</h3>
<p>Let&#39;s then just <a href="#L-compose">compose</a> a parameterized lens for accessing the
<code>text</code> of titles:</p>
<pre><code class="hljs lang-js">var textIn = language =&gt; L.compose(L.prop(&quot;titles&quot;),
                                     L.define([]),
                                     L.normalize(R.sortBy(L.get(&quot;language&quot;))),
                                     L.find(R.whereEq({language})),
                                     L.valueOr({language, text: &quot;&quot;}),
                                     L.removable(&quot;text&quot;),
                                     L.prop(&quot;text&quot;))
</code></pre>
<p>Take a moment to read through the above definition line by line.  Each part
either specifies a step in the path to select the desired element or a way in
which the data structure must be treated at that point.
The <a href="#L-prop"><code>L.prop(...)</code></a> parts are already familiar.  The other parts we
will mention below.</p>
<h3 id="querying-data">Querying data</h3>
<p>Thanks to the parameterized search
part, <a href="#L-find"><code>L.find(R.whereEq({language}))</code></a>, of the lens composition, we
can use it to query titles:</p>
<pre><code class="hljs lang-js">L.get(textIn(&quot;sv&quot;), sampleTitles)
</code></pre>
<pre><code class="hljs lang-js">L.get(textIn(&quot;en&quot;), sampleTitles)
</code></pre>
<p>The <a href="#L-find"><code>L.find</code></a> lens is a given a predicate that it then uses to find an
element from an array to focus on.  In this case the predicate is specified with
the help of Ramda&#39;s <a href="http://ramdajs.com/docs/#whereEq"><code>R.whereEq</code></a> function
that creates an equality predicate from a given template object.</p>
<h4 id="missing-data-can-be-expected">Missing data can be expected</h4>
<p>Partial lenses can generally deal with missing data.  In this case
when <a href="#L-find"><code>L.find</code></a> doesn&#39;t find an element, it instead works like a lens
to <a href="#L-append">append</a> a new element into an array.</p>
<p>So, if we use the partial lens to query a title that does not exist, we get the
default:</p>
<pre><code class="hljs lang-js">L.get(textIn(&quot;fi&quot;), sampleTitles)
</code></pre>
<p>We get this value, rather than <code>undefined</code>, thanks to
the <a href="#L-valueOr"><code>L.valueOr({language, text: &quot;&quot;})</code></a> part of our lens
composition, which ensures that we get the specified value rather than <code>null</code> or
<code>undefined</code>.  We get the default even if we query from <code>undefined</code>:</p>
<pre><code class="hljs lang-js">L.get(textIn(&quot;fi&quot;), undefined)
</code></pre>
<p>With partial lenses, <code>undefined</code> is the equivalent of empty or non-existent.</p>
<h3 id="updating-data">Updating data</h3>
<p>As with ordinary lenses, we can use the same lens to update titles:</p>
<pre><code class="hljs lang-js">L.set(textIn(&quot;en&quot;), &quot;The title&quot;, sampleTitles)
</code></pre>
<h3 id="inserting-data">Inserting data</h3>
<p>The same partial lens also allows us to insert new titles:</p>
<pre><code class="hljs lang-js">L.set(textIn(&quot;fi&quot;), &quot;Otsikko&quot;, sampleTitles)
</code></pre>
<p>There are couple of things here that require attention.</p>
<p>The reason that the newly inserted object not only has the <code>text</code> property, but
also the <code>language</code> property is due to
the <a href="#L-valueOr"><code>L.valueOr({language, text: &quot;&quot;})</code></a> part that we used to provide
a default.</p>
<p>Also note the position into which the new title was inserted.  The array of
titles is kept sorted thanks to
the <a href="#L-normalize"><code>L.normalize(R.sortBy(L.get(&quot;language&quot;)))</code></a> part of our lens.
The <a href="#L-normalize"><code>L.normalize</code></a> lens transforms the data when either read or
written with the given function.  In this case we used
Ramda&#39;s <a href="http://ramdajs.com/docs/#sortBy"><code>R.sortBy</code></a> to specify that we want
the titles to be kept sorted by language.</p>
<h3 id="removing-data">Removing data</h3>
<p>Finally, we can use the same partial lens to remove titles:</p>
<pre><code class="hljs lang-js">L.set(textIn(&quot;sv&quot;), undefined, sampleTitles)
</code></pre>
<p>Note that a single title <code>text</code> is actually a part of an object.  The key to
having the whole object vanish, rather than just the <code>text</code> property, is
the <a href="#L-removable"><code>L.removable(&quot;text&quot;)</code></a> part of our lens composition.  It
makes it so that when the <code>text</code> property is set to <code>undefined</code>, the result will
be <code>undefined</code> rather than merely an object without the <code>text</code> property.</p>
<p>If we remove all of the titles, we get the required value:</p>
<pre><code class="hljs lang-js">R.pipe(L.set(textIn(&quot;sv&quot;), undefined),
       L.set(textIn(&quot;en&quot;), undefined))(sampleTitles)
</code></pre>
<p>The <code>titles</code> property is not removed thanks to the <a href="#L-define"><code>L.define([])</code></a>
part of our lens composition.  It makes it so that when reading or writing
through the lens, <code>undefined</code> becomes the given value.</p>
<h3 id="exercises">Exercises</h3>
<p>Take out one (or
more)
<a href="#L-define"><code>L.define(...)</code></a>,
<a href="#L-normalize"><code>L.normalize(...)</code></a>, <a href="#L-valueOr"><code>L.valueOr(...)</code></a>
or <a href="#L-removable"><code>L.removable(...)</code></a> part(s) from the lens composition and try
to predict what happens when you rerun the examples with the modified lens
composition.  Verify your reasoning by actually rerunning the examples.</p>
<h3 id="shorthands">Shorthands</h3>
<p>For clarity, the previous code snippets avoided some of the shorthands that this
library supports.  In particular,</p>
<ul>
<li><a href="#L-compose"><code>L.compose(...)</code></a> can be abbreviated as an array
<a href="#L-compose"><code>[...]</code></a>,</li>
<li><a href="#L-prop"><code>L.prop(propName)</code></a> can be abbreviated as <a href="#L-prop"><code>propName</code></a>, and</li>
<li><a href="#L-set"><code>L.set(l, undefined, s)</code></a> can be abbreviated
as <a href="#L-remove"><code>L.remove(l, s)</code></a>.</li>
</ul>
<h3 id="systematic-decomposition">Systematic decomposition</h3>
<p>It is also typical to compose lenses out of short paths following the schema of
the JSON data being manipulated.  Recall the lens from the start of the
example:</p>
<pre><code class="hljs lang-jsx">L.compose(L.prop(&quot;titles&quot;),
          L.define([]),
          L.normalize(R.sortBy(L.get(&quot;language&quot;))),
          L.find(R.whereEq({language})),
          L.valueOr({language, text: &quot;&quot;}),
          L.removable(&quot;text&quot;),
          L.prop(&quot;text&quot;))
</code></pre>
<p>Following the structure or schema of the JSON, we could break this into three
separate lenses:</p>
<ul>
<li>a lens for accessing the titles of a model object,</li>
<li>a parameterized lens for querying a title object from titles, and</li>
<li>a lens for accessing the text of a title object.</li>
</ul>
<p>Furthermore, we could organize the lenses to reflect the structure of the JSON
model:</p>
<pre><code class="hljs lang-js">var Title = {
  text: [L.removable(&quot;text&quot;), &quot;text&quot;]
}

var Titles = {
  titleIn: language =&gt; [L.find(R.whereEq({language})),
                        L.valueOr({language, text: &quot;&quot;})]
}

var Model = {
  titles: [&quot;titles&quot;,
           L.define([]),
           L.normalize(R.sortBy(L.get(&quot;language&quot;)))],
  textIn: language =&gt; [Model.titles,
                       Titles.titleIn(language),
                       Title.text]
}
</code></pre>
<p>We can now say:</p>
<pre><code class="hljs lang-js">L.get(Model.textIn(&quot;sv&quot;), sampleTitles)
</code></pre>
<p>This style of organizing lenses is overkill for our toy example.  In a more
realistic case the <code>sampleTitles</code> object would contain many more properties.
Also, rather than composing a lens, like <code>Model.textIn</code> above, to access a leaf
property from the root of our object, we might actually compose lenses
incrementally as we inspect the model structure.</p>
<h3 id="manipulating-multiple-items">Manipulating multiple items</h3>
<p>So far we have used a lens to manipulate individual items.  This library also
supports <a href="#traversals">traversals</a> that compose with lenses and can target
multiple items.  Continuing on the tutorial example, let&#39;s define a traversal
that targets all the texts:</p>
<pre><code class="hljs lang-js">var texts = [Model.titles,
               L.elems,
               Title.text]
</code></pre>
<p>What makes the above a traversal is the <a href="#L-elems"><code>L.elems</code></a> part.  The result
of composing a traversal with a lens is a traversal.  The other parts of the
above composition should already be familiar from previous examples.  Note how
we were able to use the previously defined <code>Model.titles</code> and <code>Title.text</code>
lenses.</p>
<p>Now, we can use the above traversal to <a href="#L-collect"><code>collect</code></a> all the texts:</p>
<pre><code class="hljs lang-js">L.collect(texts, sampleTitles)
</code></pre>
<p>More generally, we can <a href="#L-concatAs">map and fold</a> over texts.  For example, we
can compute the length of the longest text:</p>
<pre><code class="hljs lang-js">var Max = {empty: () =&gt; 0, concat: Math.max}
L.concatAs(R.length, Max, texts, sampleTitles)
</code></pre>
<p>Of course, we can also modify texts.  For example, we could uppercase all the
titles:</p>
<pre><code class="hljs lang-js">L.modify(texts, R.toUpper, sampleTitles)
</code></pre>
<p>We can also manipulate texts selectively.  For example, we could remove all
the texts that are longer than 5 characters:</p>
<pre><code class="hljs lang-js">L.remove([texts, L.when(t =&gt; t.length &gt; 5)],
         sampleTitles)
</code></pre>
<h2 id="reference">Reference</h2>
<p>The <a href="https://wiki.haskell.org/Combinator">combinators</a> provided by this library
are available as named imports.  Typically one just imports the library as:</p>
<pre><code class="hljs lang-jsx">import * as L from &quot;partial.lenses&quot;
</code></pre>
<h3 id="optics">Optics</h3>
<p>The abstractions, <a href="#traversals">traversals</a>, <a href="#lenses">lenses</a>,
and <a href="#isomorphisms">isomorphisms</a>, provided by this library are collectively
known as <em>optics</em>.  Traversals can target any number of elements.  Lenses are a
restriction of traversals that target a single element.  Isomorphisms are a
restriction of lenses with an inverse.</p>
<p>In addition to basic optics, this library also supports more
general <a href="#transforms">transforms</a>.  Transforms allow operations, such as
modifying a single focus multiple times or even in a loop, that are not possible
with basic optics.  However, transforms are considerably harder to reason about.</p>
<p>Some optics libraries provide many more abstractions, such as &quot;optionals&quot;,
&quot;prisms&quot; and &quot;folds&quot;, to name a few, forming a DAG.  Aside from being
conceptually important, many of those abstractions are not only useful but
required in a statically typed setting where data structures have precise
constraints on their shapes, so to speak, and operations on data structures must
respect those constraints at <em>all</em> times.  In partial lenses, however, the idea
is to manage without explicitly providing such abstractions.</p>
<p>In a dynamically typed language like JavaScript, the shapes of run-time objects
are naturally <em>malleable</em>.  Nothing immediately breaks if a new object is
created as a copy of another object by adding or removing a property, for
example.  We can exploit this to our advantage by considering all optics as
<em>partial</em>.  A partial optic, as manifested in this library, may be intended to
operate on data structures of a specific type, such as arrays or objects, but
also accepts the possibility that it may be given any valid JSON object or
<code>undefined</code> as input.  When the input does not match the expectation of a
partial lens, the input is treated as being <code>undefined</code>.  This allows specific
partial optics, such as the simple <a href="#L-prop"><code>L.prop</code></a> lens, to be used in a
wider range of situations than corresponding total optics.</p>
<h4 id="on-partiality">On partiality</h4>
<p>As mentioned many times, in this library all of the optics are
essentially <a href="https://en.wikipedia.org/wiki/Partial_function">partial functions</a>.
What does this mean?</p>
<p>By definition, a <em>total function</em>, or just a <em>function</em>, is defined for all
possible inputs.  A <em>partial function</em>, on the other hand, may not be defined
for all inputs.</p>
<p>As an example, consider an operation to return the first element of an array.
Such an operation cannot be total unless the input is restricted to arrays that
have at least one element.  One might think that the operation could be made
total by returning a special value in case the input array is empty, but that is
no longer the same operation&mdash;the special value is not the first element of
the array.  Now, in partial lenses the idea is that in case the input does not
match the expectation of the operation, then the input is treated as being
<code>undefined</code>.  This makes the optics in this library partial.</p>
<p>Making all optics partial has a number of consequences.  For one thing, it can
potentially hide bugs: an incorrectly specified optic treats the input as
<code>undefined</code> and may seem to work without raising an error.  However, partiality
also has a number of benefits.  In particular, it allows optics to seamlessly
support both insertion and removal.  It also allows to reduce the number of
necessary abstractions.  And it tends to make compositions of optics more
concise with fewer required parts.</p>
<h4 id="on-composability">On composability</h4>
<p>As mentioned in the preface, optics are
highly <a href="https://en.wikipedia.org/wiki/Composability">composable</a>.  What does
this mean?</p>
<p>A lot of libraries these days claim to be composable.  Is any collection of
functions composable?  In the opinion of the author of this library, in order
for something to be called &quot;composable&quot;, a couple of conditions must be
fulfilled:</p>
<ol>
<li>There must be an operation or operations that perform composition.</li>
<li>There must be simple laws on how compositions behave.</li>
</ol>
<p>Conversely, if there is no operation to perform composition or there are no
useful simplifying laws on how compositions behave, then one should not call
such a thing composable.</p>
<p>Now, optics are composable in several ways and in each of those ways there is a
an operation to perform the composition and laws on how such composed optics
behave.  Here is a table of the means of composition supported by this library:</p>
<table>
<thead>
<tr>
<th></th>
<th>Operation</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nesting</td>
<td><a href="#L-compose"><code>L.compose(...os)</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Monoid">Monoid</a> over <a href="http://cs.stackexchange.com/questions/18847/if-dynamically-typed-languages-are-truly-statically-typed-unityped-languages-w">unityped</a> optics</td>
</tr>
<tr>
<td>Recursing</td>
<td><a href="#L-lazy"><code>L.lazy(o =&gt; o)</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Fixed point</a></td>
</tr>
<tr>
<td>Adapting</td>
<td><a href="#L-orElse"><code>L.orElse(lb, la)</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Semigroup">Semigroup</a> over <a href="#lenses">lenses</a></td>
</tr>
<tr>
<td>Choosing</td>
<td><a href="#L-choice"><code>L.choice(...ls)</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Monoid">Monoid</a> over <a href="#lenses">lenses</a></td>
</tr>
<tr>
<td>Querying</td>
<td><a href="#L-chain"><code>L.chain(x =&gt; o, o)</code></a></td>
<td><a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus">MonadPlus</a></td>
</tr>
<tr>
<td>Picking</td>
<td><a href="#L-pick"><code>L.pick({...p:l})</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Product_(category_theory)">Product</a> of <a href="#lenses">lenses</a></td>
</tr>
<tr>
<td>Branching</td>
<td><a href="#L-branch"><code>L.branch({...p:t})</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Coproduct">Coproduct</a> of <a href="#traversals">traversals</a></td>
</tr>
</tbody>
</table>
<p>The above table and, in particular, the semantics column is by no means
complete.  In particular, the documentation of this library does not generally
spell out proofs of the semantics.</p>
<h5 id="on-lens-laws">On lens laws</h5>
<p>Aside from understanding laws on how forms of composition behave, it is useful
to understand laws that are specific to operations on lenses and optics, in
general.  As described in the
paper
<a href="http://sebfisch.github.io/research/pub/Fischer+MPC15.pdf">A clear picture of lens laws</a>,
many laws have been formulated for lenses and it can be useful to have lenses
that do not necessarily obey some laws.</p>
<p>Here is a snippet that demonstrates that partial lenses can obey the laws of, so
called, <em>well behaved lenses</em>:</p>
<pre><code class="hljs lang-js">var elem = 2
var data = {x: 1}
var lens = &quot;x&quot;

var test = (actual, expected) =&gt; R.equals(actual, expected) || actual

R.identity({
  GetSet: test( L.set(lens, L.get(lens, data), data), data ),
  SetGet: test( L.get(lens, L.set(lens, elem, data)), elem )
})
</code></pre>
<p>Note, however, that <em>partial</em> lenses are not (total) lenses.  You might want
to <a href="https://calmm-js.github.io/partial.lenses#on-lens-laws">▶ play</a> with the
laws in your browser.</p>
<h4 id="operations-on-optics">Operations on optics</h4>
<h5 id="-a-id-l-modify-a-contents-https-github-com-calmm-js-partial-lenses-l-modify-l-modify-optic-maybevalue-index-maybevalue-maybedata-maybedata-l-modify-l-modify-poptic-s-a-maybe-a-index-maybe-a-maybe-s-maybe-s-"><a id="L-modify"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-modify">■</a> <a href="#L-modify" title="L.modify: POptic s a -&gt; ((Maybe a, Index) -&gt; Maybe a) -&gt; Maybe s -&gt; Maybe s"><code>L.modify(optic, (maybeValue, index) =&gt; maybeValue, maybeData) ~&gt; maybeData</code></a></h5>
<p><code>L.modify</code> allows one to map over the focused element</p>
<pre><code class="hljs lang-js">L.modify([&quot;elems&quot;, 0, &quot;x&quot;], R.inc, {elems: [{x: 1, y: 2}, {x: 3, y: 4}]})
</code></pre>
<p>or, when using a <a href="#traversals">traversal</a>, elements</p>
<pre><code class="hljs lang-js">L.modify([&quot;elems&quot;, L.elems, &quot;x&quot;],
         R.dec,
         {elems: [{x: 1, y: 2}, {x: 3, y: 4}]})
</code></pre>
<p>of a data structure.</p>
<h5 id="-a-id-l-remove-a-contents-https-github-com-calmm-js-partial-lenses-l-remove-l-remove-optic-maybedata-maybedata-l-remove-l-remove-poptic-s-a-maybe-s-maybe-s-"><a id="L-remove"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-remove">■</a> <a href="#L-remove" title="L.remove: POptic s a -&gt; Maybe s -&gt; Maybe s"><code>L.remove(optic, maybeData) ~&gt; maybeData</code></a></h5>
<p><code>L.remove</code> allows one to remove the focused element</p>
<pre><code class="hljs lang-js">L.remove([0, &quot;x&quot;], [{x: 1}, {x: 2}, {x: 3}])
</code></pre>
<p>or, when using a <a href="#traversals">traversal</a>, elements</p>
<pre><code class="hljs lang-js">L.remove([L.elems, &quot;x&quot;, L.when(x =&gt; x &gt; 1)], [{x: 1}, {x: 2, y: 1}, {x: 3}])
</code></pre>
<p>from a data structure.</p>
<p>Note that <code>L.remove(optic, maybeData)</code> is equivalent
to <a href="#L-set"><code>L.set(lens, undefined, maybeData)</code></a>.  With partial lenses, setting
to <code>undefined</code> typically has the effect of removing the focused element.</p>
<h5 id="-a-id-l-set-a-contents-https-github-com-calmm-js-partial-lenses-l-set-l-set-optic-maybevalue-maybedata-maybedata-l-set-l-set-poptic-s-a-maybe-a-maybe-s-maybe-s-"><a id="L-set"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-set">■</a> <a href="#L-set" title="L.set: POptic s a -&gt; Maybe a -&gt; Maybe s -&gt; Maybe s"><code>L.set(optic, maybeValue, maybeData) ~&gt; maybeData</code></a></h5>
<p><code>L.set</code> allows one to replace the focused element</p>
<pre><code class="hljs lang-js">L.set([&quot;a&quot;, 0, &quot;x&quot;], 11, {id: &quot;z&quot;})
</code></pre>
<p>or, when using a <a href="#traversals">traversal</a>, elements</p>
<pre><code class="hljs lang-js">L.set([L.elems, &quot;x&quot;, L.when(x =&gt; x &gt; 1)], -1, [{x: 1}, {x: 2, y: 1}, {x: 3}])
</code></pre>
<p>of a data structure.</p>
<p>Note that <code>L.set(lens, maybeValue, maybeData)</code> is equivalent
to <a href="#L-modify"><code>L.modify(lens, R.always(maybeValue), maybeData)</code></a>.</p>
<h4 id="nesting">Nesting</h4>
<h5 id="-a-id-l-compose-a-contents-https-github-com-calmm-js-partial-lenses-l-compose-l-compose-optics-optic-l-compose-l-compose-poptic-s-s1-poptic-sn-a-poptic-s-a-or-optics-"><a id="L-compose"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-compose">■</a> <a href="#L-compose" title="L.compose: (POptic s s1, ...POptic sN a) -&gt; POptic s a"><code>L.compose(...optics) ~&gt; optic</code></a> or <code>[...optics]</code></h5>
<p><code>L.compose</code> performs composition of optics and ordinary functions.  The
following equations characterize composition:</p>
<pre><code class="hljs lang-jsx">                  L.compose() = L.identity
                 L.compose(l) = l
L.modify(L.compose(o, ...os)) = R.compose(L.modify(o), ...os.map(L.modify))
   L.get(L.compose(o, ...os)) = R.pipe(L.get(o), ...os.map(L.get))
</code></pre>
<p>Furthermore, in this library, an array of optics <code>[...optics]</code> is treated as a
composition <code>L.compose(...optics)</code>.  Using the array notation, the above
equations can be written as:</p>
<pre><code class="hljs lang-jsx">                  [] = L.identity
                 [l] = l
L.modify([o, ...os]) = R.compose(L.modify(o), ...os.map(L.modify))
   L.get([o, ...os]) = R.pipe(L.get(o), ...os.map(L.get))
</code></pre>
<p>For example:</p>
<pre><code class="hljs lang-js">L.set([&quot;a&quot;, 1], &quot;a&quot;, {a: [&quot;b&quot;, &quot;c&quot;]})
</code></pre>
<pre><code class="hljs lang-js">L.get([&quot;a&quot;, 1], {a: [&quot;b&quot;, &quot;c&quot;]})
</code></pre>
<p>You can also directly compose optics with ordinary functions (with max arity of
2).  The result of such a composition is a read-only optic.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get([&quot;x&quot;, x =&gt; x + 1], {x: 1})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;x&quot;, x =&gt; x + 1], 3, {x: 1})
</code></pre>
<p>Note that <a href="http://ramdajs.com/docs/#compose"><code>R.compose</code></a> is not the same as
<code>L.compose</code>.</p>
<h4 id="querying">Querying</h4>
<h5 id="-a-id-l-chain-a-contents-https-github-com-calmm-js-partial-lenses-l-chain-l-chain-value-index-optic-optic-optic-l-chain-l-chain-a-index-poptic-s-b-poptic-s-a-poptic-s-b-"><a id="L-chain"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-chain">■</a> <a href="#L-chain" title="L.chain: ((a, Index) -&gt; POptic s b) -&gt; POptic s a -&gt; POptic s b"><code>L.chain((value, index) =&gt; optic, optic) ~&gt; optic</code></a></h5>
<p><code>L.chain(toOptic, optic)</code> is equivalent to</p>
<pre><code class="hljs lang-jsx">L.compose(optic, L.choose((maybeValue, index) =&gt;
  maybeValue === undefined
  ? L.zero
  : toOptic(maybeValue, index)))
</code></pre>
<p>Note that with the <a href="http://ramdajs.com/docs/#always"><code>R.always</code></a>,
<code>L.chain</code>, <a href="#L-choice"><code>L.choice</code></a> and <a href="#L-zero"><code>L.zero</code></a> combinators, one can
consider optics as subsuming the maybe monad.</p>
<h5 id="-a-id-l-choice-a-contents-https-github-com-calmm-js-partial-lenses-l-choice-l-choice-lenses-optic-l-choice-l-choice-plens-s-a-poptic-s-a-"><a id="L-choice"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-choice">■</a> <a href="#L-choice" title="L.choice: (...PLens s a) -&gt; POptic s a"><code>L.choice(...lenses) ~&gt; optic</code></a></h5>
<p><code>L.choice</code> returns a partial optic that acts like the first of the given lenses
whose view is not <code>undefined</code> on the given data structure.  When the views of
all of the given lenses are <code>undefined</code>, the returned lens acts
like <a href="#L-zero"><code>L.zero</code></a>, which is the identity element of <code>L.choice</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify([L.elems, L.choice(&quot;a&quot;, &quot;d&quot;)], R.inc, [{R: 1}, {a: 1}, {d: 2}])
</code></pre>
<h5 id="-a-id-l-choose-a-contents-https-github-com-calmm-js-partial-lenses-l-choose-l-choose-maybevalue-index-optic-optic-l-choose-l-choose-maybe-s-index-poptic-s-a-poptic-s-a-"><a id="L-choose"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-choose">■</a> <a href="#L-choose" title="L.choose: ((Maybe s, Index) -&gt; POptic s a) -&gt; POptic s a"><code>L.choose((maybeValue, index) =&gt; optic) ~&gt; optic</code></a></h5>
<p><code>L.choose</code> creates an optic whose operation is determined by the given function
that maps the underlying view, which can be <code>undefined</code>, to an optic.  In other
words, the <code>L.choose</code> combinator allows an optic to be constructed <em>after</em>
examining the data structure being manipulated.</p>
<p>For example, given:</p>
<pre><code class="hljs lang-js">var majorAxis =
  L.choose(({x, y} = {}) =&gt; Math.abs(x) &lt; Math.abs(y) ? &quot;y&quot; : &quot;x&quot;)
</code></pre>
<p>we get:</p>
<pre><code class="hljs lang-js">L.get(majorAxis, {x: 1, y: 2})
</code></pre>
<pre><code class="hljs lang-js">L.get(majorAxis, {x: -3, y: 1})
</code></pre>
<pre><code class="hljs lang-js">L.modify(majorAxis, R.negate, {x: 2, y: -3})
</code></pre>
<h5 id="-a-id-l-optional-a-contents-https-github-com-calmm-js-partial-lenses-l-optional-l-optional-optic-l-optional-l-optional-poptic-a-a-"><a id="L-optional"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-optional">■</a> <a href="#L-optional" title="L.optional: POptic a a"><code>L.optional ~&gt; optic</code></a></h5>
<p><code>L.optional</code> is an optic over an optional element.  When used as a traversal,
and the focus is <code>undefined</code>, the traversal is empty.  When used as a lens, and
the focus is <code>undefined</code>, the lens will be read-only.</p>
<p>As an example, consider the difference between:</p>
<pre><code class="hljs lang-js">L.set([L.elems, &quot;x&quot;], 3, [{x: 1}, {y: 2}])
</code></pre>
<p>and:</p>
<pre><code class="hljs lang-js">L.set([L.elems, &quot;x&quot;, L.optional], 3, [{x: 1}, {y: 2}])
</code></pre>
<p>Note that <code>L.optional</code> is equivalent
to <a href="#L-when"><code>L.when(x =&gt; x !== undefined)</code></a>.</p>
<h5 id="-a-id-l-when-a-contents-https-github-com-calmm-js-partial-lenses-l-when-l-when-maybevalue-index-testable-optic-l-when-l-when-maybe-a-index-boolean-poptic-a-a-"><a id="L-when"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-when">■</a> <a href="#L-when" title="L.when: ((Maybe a, Index) -&gt; Boolean) -&gt; POptic a a"><code>L.when((maybeValue, index) =&gt; testable) ~&gt; optic</code></a></h5>
<p><code>L.when</code> allows one to selectively skip elements within a traversal or to
selectively turn a lens into a read-only lens whose view is <code>undefined</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify([L.elems, L.when(x =&gt; x &gt; 0)], R.negate, [0, -1, 2, -3, 4])
</code></pre>
<p>Note that <code>L.when(p)</code> is equivalent
to <a href="#L-choose"><code>L.choose((x, i) =&gt; p(x, i) ? L.identity : L.zero)</code></a>.</p>
<h5 id="-a-id-l-zero-a-contents-https-github-com-calmm-js-partial-lenses-l-zero-l-zero-optic-l-zero-l-zero-poptic-s-a-"><a id="L-zero"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-zero">■</a> <a href="#L-zero" title="L.zero: POptic s a"><code>L.zero ~&gt; optic</code></a></h5>
<p><code>L.zero</code> is the identity element of <a href="#L-choice"><code>L.choice</code></a>
and <a href="#L-chain"><code>L.chain</code></a>.  As a traversal, <code>L.zero</code> is a traversal of no
elements and as a lens, i.e. when used with <a href="#L-get"><code>L.get</code></a>, <code>L.zero</code> is a
read-only lens whose view is always <code>undefined</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.collect([L.elems,
           L.choose(x =&gt; (R.is(Array, x) ? L.elems :
                          R.is(Object, x) ? &quot;x&quot; :
                          L.zero))],
          [1, {x: 2}, [3,4]])
</code></pre>
<h4 id="recursing">Recursing</h4>
<h5 id="-a-id-l-lazy-a-contents-https-github-com-calmm-js-partial-lenses-l-lazy-l-lazy-optic-optic-optic-l-lazy-l-lazy-poptic-s-a-poptic-s-a-poptic-s-a-"><a id="L-lazy"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-lazy">■</a> <a href="#L-lazy" title="L.lazy: (POptic s a -&gt; POptic s a) -&gt; POptic s a"><code>L.lazy(optic =&gt; optic) ~&gt; optic</code></a></h5>
<p><code>L.lazy</code> can be used to construct optics lazily.  The function given to <code>L.lazy</code>
is passed a forwarding proxy to its return value and can also make forward
references to other optics and possibly construct a recursive optic.</p>
<p>Note that when using <code>L.lazy</code> to construct a recursive optic, it will only work
in a meaningful way when the recursive uses are either <a href="#L-compose">precomposed</a>
or <a href="#L-seq">presequenced</a> with some other optic in a way that neither causes
immediate nor unconditional recursion.</p>
<p>For example, here is a traversal that targets all the primitive elements in a
data structure of nested arrays and objects:</p>
<pre><code class="hljs lang-js">var flatten = [L.optional, L.lazy(rec =&gt; {
  const elems = [L.elems, rec]
  const values = [L.values, rec]
  return L.choose(x =&gt; (x instanceof Array ? elems :
                        x instanceof Object ? values :
                        L.identity))
})]
</code></pre>
<p>Note that the above creates a cyclic representation of the traversal.</p>
<p>Now, for example:</p>
<pre><code class="hljs lang-js">L.collect(flatten, [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<pre><code class="hljs lang-js">L.modify(flatten, x =&gt; x+1, [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<pre><code class="hljs lang-js">L.remove([flatten, L.when(x =&gt; 3 &lt;= x &amp;&amp; x &lt;= 4)],
         [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<h4 id="debugging">Debugging</h4>
<h5 id="-a-id-l-log-a-contents-https-github-com-calmm-js-partial-lenses-l-log-l-log-labels-optic-l-log-l-log-any-poptic-s-s-"><a id="L-log"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-log">■</a> <a href="#L-log" title="L.log: (...Any) -&gt; POptic s s"><code>L.log(...labels) ~&gt; optic</code></a></h5>
<p><code>L.log(...labels)</code> is an identity optic that
outputs
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log"><code>console.log</code></a>
messages with the given labels
(or
<a href="https://nodejs.org/api/console.html#console_console_log_data">format in Node.js</a>)
when data flows in either direction, <code>get</code> or <code>set</code>, through the lens.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get([&quot;x&quot;, L.log()], {x: 10})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;x&quot;, L.log(&quot;x&quot;)], &quot;11&quot;, {x: 10})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;x&quot;, L.log(&quot;%s x: %j&quot;)], &quot;11&quot;, {x: 10})
</code></pre>
<h4 id="internals">Internals</h4>
<h5 id="-a-id-l-tofunction-a-contents-https-github-com-calmm-js-partial-lenses-l-tofunction-l-tofunction-optic-optic-l-tofunction-l-tofunction-poptic-s-a-functor-applicative-c-maybe-a-index-c-b-maybe-s-index-c-t-"><a id="L-toFunction"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-toFunction">■</a> <a href="#L-toFunction" title="L.toFunction: POptic s a -&gt; ((Functor|Applicative) c, (Maybe a, Index) -&gt; c b, Maybe s, Index) -&gt; c t"><code>L.toFunction(optic) ~&gt; optic</code></a></h5>
<p><code>L.toFunction</code> converts a given optic, which can be a <a href="#L-prop">string</a>,
an <a href="#L-index">integer</a>, an <a href="#L-compose">array</a>, or a function to a function.
This can be useful for implementing new combinators and operations that cannot
otherwise be implemented using the combinators provided by this library.</p>
<p>For <a href="#isomorphisms">isomorphisms</a> and <a href="#lenses">lenses</a>, the returned function
will have the signature</p>
<pre><code class="hljs lang-jsx">(Functor c, (Maybe a, Index) -&gt; c b, Maybe s, Index) -&gt; c t
</code></pre>
<p>for <a href="#traversals">traversals</a> the signature will be</p>
<pre><code class="hljs lang-jsx">(Applicative c, (Maybe a, Index) -&gt; c b, Maybe s, Index) -&gt; c t
</code></pre>
<p>and for <a href="#transforms">transforms</a> the signature will be</p>
<pre><code class="hljs lang-jsx">(Monad c, (Maybe a, Index) -&gt; c b, Maybe s, Index) -&gt; c t
</code></pre>
<p>Note that the above signatures are written using the &quot;tupled&quot; parameter notation
<code>(...) -&gt; ...</code> to denote that the functions are not curried.</p>
<p>The
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#functor"><code>Functor</code></a>,
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#applicative"><code>Applicative</code></a>,
and
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#monad"><code>Monad</code></a> arguments
are expected to conform to
their
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md">Static Land</a>
specifications.</p>
<p>Note that, in conjunction with partial optics, it may be advantageous to have
the algebras to allow for partiality.  With traversals it is also possible, for
example, to simply post compose optics with <a href="#L-optional"><code>L.optional</code></a> to
skip <code>undefined</code> elements.</p>
<h3 id="transforms">Transforms</h3>
<p>A transform operates over focuses that may overlap and may be visited multiple
times.  This allows operations that are impossible to implement using other
optics, but also potentially makes it much more difficult to reason about the
results.  Transforms can only be <a href="#L-modify">modified</a>, <a href="#L-set">set</a>
and <a href="#L-remove">removed</a>.</p>
<h4 id="sequencing">Sequencing</h4>
<h5 id="-a-id-l-seq-a-contents-https-github-com-calmm-js-partial-lenses-l-seq-l-seq-optics-transform-l-seq-l-seq-poptic-s-a-ptransform-s-a-"><a id="L-seq"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-seq">■</a> <a href="#L-seq" title="L.seq: (...POptic s a) -&gt; PTransform s a"><code>L.seq(...optics) ~&gt; transform</code></a></h5>
<p><code>L.seq</code> creates a transform that modifies the focus with each of the given
optics in sequence.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify(L.seq(L.identity, L.identity, L.identity), x =&gt; [x], 1)
</code></pre>
<p>Here is an example of a bottom-up transform over a data structure of nested
objects and arrays:</p>
<pre><code class="hljs lang-js">var everywhere = [L.optional, L.lazy(rec =&gt; {
  const elems = [L.elems, rec]
  const values = [L.values, rec]
  return L.seq(L.choose(x =&gt; (x instanceof Array ? elems :
                              x instanceof Object ? values :
                              L.zero)),
               L.identity)
})]
</code></pre>
<p>The above <code>everywhere</code> transform is similar to
the <a href="https://github.com/polytypic/fastener#F-everywhere"><code>F.everywhere</code></a>
transform of the <a href="https://github.com/polytypic/fastener"><code>fastener</code></a>
zipper-library.  Note that the above <code>everywhere</code> and the <a href="#L-lazy"><code>flatten</code></a>
example differ in that <code>flatten</code> only targets the non-object and non-array
elements of the data structure while <code>everywhere</code> also targets those.</p>
<pre><code class="hljs lang-js">L.modify(everywhere, x =&gt; [x], {xs: [{x: 1}, {x: 2}]})
</code></pre>
<h3 id="traversals">Traversals</h3>
<p>A traversal operates over a collection of non-overlapping focuses that are
visited only once and can, for example,
be
<a href="#L-collect">collected</a>,
<a href="#L-concatAs">folded</a>, <a href="#L-modify">modified</a>, <a href="#L-set">set</a>
and <a href="#L-remove">removed</a>.</p>
<h4 id="operations-on-traversals">Operations on traversals</h4>
<h5 id="-a-id-l-concat-a-contents-https-github-com-calmm-js-partial-lenses-l-concat-l-concat-monoid-traversal-maybedata-value-l-concat-l-concat-monoid-a-ptraversal-s-a-maybe-s-a-"><a id="L-concat"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-concat">■</a> <a href="#L-concat" title="L.concat: Monoid a -&gt; (PTraversal s a -&gt; Maybe s -&gt; a)"><code>L.concat(monoid, traversal, maybeData) ~&gt; value</code></a></h5>
<p><code>L.concat({empty, concat}, t, s)</code> performs a fold, using the given <code>concat</code> and
<code>empty</code> operations, over the elements focused on by the given traversal or lens
<code>t</code> from the given data structure <code>s</code>.  The <code>concat</code> operation and the constant
returned by <code>empty()</code> should form
a
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#monoid">monoid</a> over
the values focused on by <code>t</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var Sum = {empty: () =&gt; 0, concat: (x, y) =&gt; x + y}
L.concat(Sum, L.elems, [1, 2, 3])
</code></pre>
<p>Note that <code>L.concat</code> is staged so that after given the first argument,
<code>L.concat(m)</code>, a computation step is performed.</p>
<h5 id="-a-id-l-concatas-a-contents-https-github-com-calmm-js-partial-lenses-l-concatas-l-concatas-maybevalue-index-value-monoid-traversal-maybedata-value-l-concatas-l-concatas-maybe-a-index-r-monoid-r-ptraversal-s-a-maybe-s-r-"><a id="L-concatAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-concatAs">■</a> <a href="#L-concatAs" title="L.concatAs: ((Maybe a, Index) -&gt; r) -&gt; Monoid r -&gt; (PTraversal s a -&gt; Maybe s -&gt; r)"><code>L.concatAs((maybeValue, index) =&gt; value, monoid, traversal, maybeData) ~&gt; value</code></a></h5>
<p><code>L.concatAs(xMi2r, {empty, concat}, t, s)</code> performs a map, using given function
<code>xMi2r</code>, and fold, using the given <code>concat</code> and <code>empty</code> operations, over the
elements focused on by the given traversal or lens <code>t</code> from the given data
structure <code>s</code>.  The <code>concat</code> operation and the constant returned by <code>empty()</code>
should form
a
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#monoid">monoid</a> over
the values returned by <code>xMi2r</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.concatAs(x =&gt; x, Sum, L.elems, [1, 2, 3])
</code></pre>
<p>Note that <code>L.concatAs</code> is staged so that after given the first two arguments,
<code>L.concatAs(f, m)</code>, a computation step is performed.</p>
<h5 id="-a-id-l-merge-a-contents-https-github-com-calmm-js-partial-lenses-l-merge-l-merge-monoid-traversal-maybedata-value-l-merge-l-merge-monoid-a-ptraversal-s-a-maybe-s-a-"><a id="L-merge"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-merge">■</a> <del><a href="#L-merge" title="L.merge: Monoid a -&gt; (PTraversal s a -&gt; Maybe s -&gt; a)"><code>L.merge(monoid, traversal, maybeData) ~&gt; value</code></a></del></h5>
<p><strong>WARNING: <code>L.merge</code> is obsolete, just use <a href="#L-concat"><code>L.concat</code></a>.</strong></p>
<p><code>L.merge({empty, concat}, t, s)</code> performs a fold, using the given <code>concat</code> and
<code>empty</code> operations, over the elements focused on by the given traversal or lens
<code>t</code> from the given data structure <code>s</code>.  The <code>concat</code> operation and the constant
returned by <code>empty()</code> should form
a
<a href="https://en.wikipedia.org/wiki/Monoid#Commutative_monoid">commutative</a> <a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#monoid">monoid</a> over
the values focused on by <code>t</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.merge(Sum, L.elems, [1, 2, 3])
</code></pre>
<p>Note that <code>L.merge</code> is staged so that after given the first argument,
<code>L.merge(m)</code>, a computation step is performed.</p>
<p>See also: <a href="#L-concat"><code>L.concat</code></a>.</p>
<h5 id="-a-id-l-mergeas-a-contents-https-github-com-calmm-js-partial-lenses-l-mergeas-l-mergeas-maybevalue-index-value-monoid-traversal-maybedata-value-l-mergeas-l-mergeas-maybe-a-index-r-monoid-r-ptraversal-s-a-maybe-s-r-"><a id="L-mergeAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-mergeAs">■</a> <del><a href="#L-mergeAs" title="L.mergeAs: ((Maybe a, Index) -&gt; r) -&gt; Monoid r -&gt; (PTraversal s a -&gt; Maybe s -&gt; r)"><code>L.mergeAs((maybeValue, index) =&gt; value, monoid, traversal, maybeData) ~&gt; value</code></a></del></h5>
<p><strong>WARNING: <code>L.mergeAs</code> is obsolete, just use <a href="#L-concatAs"><code>L.concatAs</code></a>.</strong></p>
<p><code>L.mergeAs(xMi2r, {empty, concat}, t, s)</code> performs a map, using given function
<code>xMi2r</code>, and fold, using the given <code>concat</code> and <code>empty</code> operations, over the
elements focused on by the given traversal or lens <code>t</code> from the given data
structure <code>s</code>.  The <code>concat</code> operation and the constant returned by <code>empty()</code>
should form
a
<a href="https://en.wikipedia.org/wiki/Monoid#Commutative_monoid">commutative</a> <a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#monoid">monoid</a> over
the values returned by <code>xMi2r</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.mergeAs(x =&gt; x, Sum, L.elems, [1, 2, 3])
</code></pre>
<p>Note that <code>L.mergeAs</code> is staged so that after given the first two arguments,
<code>L.mergeAs(f, m)</code>, a computation step is performed.</p>
<p>See also: <a href="#L-concatAs"><code>L.concatAs</code></a>.</p>
<h4 id="folds-over-traversals">Folds over traversals</h4>
<h5 id="-a-id-l-all-a-contents-https-github-com-calmm-js-partial-lenses-l-all-l-all-maybevalue-index-testable-traversal-maybedata-boolean-l-all-l-all-maybe-a-index-boolean-ptraversal-s-a-boolean-"><a id="L-all"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-all">■</a> <a href="#L-all" title="L.all: ((Maybe a, Index) -&gt; Boolean) -&gt; PTraversal s a -&gt; Boolean"><code>L.all((maybeValue, index) =&gt; testable, traversal, maybeData) ~&gt; boolean</code></a></h5>
<p><code>L.all</code> determines whether all of the elements focused on by the given traversal
satisfy the given predicate.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.all(x =&gt; 1 &lt;= x &amp;&amp; x &lt;= 6,
      flatten,
      [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<p>See also: <a href="#L-any"><code>L.any</code></a> and <a href="#L-firstAs"><code>L.firstAs</code></a>.</p>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-and-a-contents-https-github-com-calmm-js-partial-lenses-l-and-l-and-traversal-maybedata-boolean-l-and-l-or-ptraversal-s-boolean-boolean-"><a id="L-and"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-and">■</a> <a href="#L-and" title="L.or: PTraversal s Boolean -&gt; Boolean"><code>L.and(traversal, maybeData) ~&gt; boolean</code></a></h5>
<p><code>L.and</code> determines whether all of the elements focused on by the given traversal
are truthy.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.and(L.elems, [])
</code></pre>
<p>Note that <code>L.and</code> is equivalent to <a href="#L-all"><code>L.all(R.identity)</code></a>.  See
also: <a href="#L-or"><code>L.or</code></a>.</p>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-any-a-contents-https-github-com-calmm-js-partial-lenses-l-any-l-any-maybevalue-index-testable-traversal-maybedata-boolean-l-any-l-any-maybe-a-index-boolean-ptraversal-s-a-boolean-"><a id="L-any"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-any">■</a> <a href="#L-any" title="L.any: ((Maybe a, Index) -&gt; Boolean) -&gt; PTraversal s a -&gt; Boolean"><code>L.any((maybeValue, index) =&gt; testable, traversal, maybeData) ~&gt; boolean</code></a></h5>
<p><code>L.any</code> determines whether any of the elements focused on by the given traversal
satisfy the given predicate.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.any(x =&gt; x &gt; 5,
      flatten,
      [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<p>See also: <a href="#L-all"><code>L.all</code></a> and <a href="#L-firstAs"><code>L.firstAs</code></a>.</p>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-collect-a-contents-https-github-com-calmm-js-partial-lenses-l-collect-l-collect-traversal-maybedata-values-l-collect-l-collect-ptraversal-s-a-maybe-s-a-"><a id="L-collect"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-collect">■</a> <a href="#L-collect" title="L.collect: PTraversal s a -&gt; Maybe s -&gt; [a]"><code>L.collect(traversal, maybeData) ~&gt; [...values]</code></a></h5>
<p><code>L.collect</code> returns an array of the defined elements focused on by the given
traversal or lens from a data structure.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.collect([&quot;xs&quot;, L.elems, &quot;x&quot;], {xs: [{x: 1}, {x: 2}]})
</code></pre>
<p>Note that <code>L.collect</code> is equivalent
to <a href="#L-collectAs"><code>L.collectAs(R.identity)</code></a>.</p>
<h5 id="-a-id-l-collectas-a-contents-https-github-com-calmm-js-partial-lenses-l-collectas-l-collectas-maybevalue-index-maybevalue-traversal-maybedata-values-l-collectas-l-collectas-maybe-a-index-maybe-b-ptraversal-s-a-maybe-s-b-"><a id="L-collectAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-collectAs">■</a> <a href="#L-collectAs" title="L.collectAs: ((Maybe a, Index) -&gt; Maybe b) -&gt; PTraversal s a -&gt; Maybe s -&gt; [b]"><code>L.collectAs((maybeValue, index) =&gt; maybeValue, traversal, maybeData) ~&gt; [...values]</code></a></h5>
<p><code>L.collectAs</code> returns an array of the elements focused on by the given traversal
or lens from a data structure and mapped by the given function to a defined
value.  Given a lens, there will be 0 or 1 elements in the returned array.  Note
that a partial <em>lens</em> always targets an element, but <code>L.collectAs</code> implicitly
skips elements that are mapped to <code>undefined</code> by the given function.  Given a
traversal, there can be any number of elements in the array returned by
<code>L.collectAs</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.collectAs(R.negate, [&quot;xs&quot;, L.elems, &quot;x&quot;], {xs: [{x: 1}, {x: 2}]})
</code></pre>
<p><code>L.collectAs(toMaybe, traversal, maybeData)</code> is equivalent
to
<a href="#L-concatAs"><code>L.concatAs(R.pipe(toMaybe, toCollect), Collect, traversal, maybeData)</code></a> where
<code>Collect</code> and <code>toCollect</code> are defined as follows:</p>
<pre><code class="hljs lang-js">var Collect = {empty: R.always([]), concat: R.concat}
var toCollect = x =&gt; x !== undefined ? [x] : []
</code></pre>
<p>So:</p>
<pre><code class="hljs lang-js">L.concatAs(R.pipe(R.negate, toCollect),
           Collect,
           [&quot;xs&quot;, L.elems, &quot;x&quot;],
           {xs: [{x: 1}, {x: 2}]})
</code></pre>
<p>The internal implementation of <code>L.collectAs</code> is optimized and faster than the
above naïve implementation.</p>
<h5 id="-a-id-l-first-a-contents-https-github-com-calmm-js-partial-lenses-l-first-l-first-traversal-maybedata-maybevalue-l-first-l-first-ptraversal-s-a-maybe-s-maybe-a-"><a id="L-first"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-first">■</a> <a href="#L-first" title="L.first: PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.first(traversal, maybeData) ~&gt; maybeValue</code></a></h5>
<p><code>L.first</code> goes lazily over the elements focused on by the given traversal and
returns the first non-<code>undefined</code> element.</p>
<pre><code class="hljs lang-js">L.first([L.elems, &quot;y&quot;], [{x:1},{y:2},{z:3}])
</code></pre>
<p>Note that <code>L.first</code> is equivalent to <a href="#L-firstAs"><code>L.firstAs(R.identity)</code></a>.</p>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-firstas-a-contents-https-github-com-calmm-js-partial-lenses-l-firstas-l-firstas-maybevalue-index-maybevalue-traversal-maybedata-maybevalue-l-firstas-l-firstas-maybe-a-index-maybe-b-ptraversal-s-a-maybe-s-maybe-b-"><a id="L-firstAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-firstAs">■</a> <a href="#L-firstAs" title="L.firstAs: ((Maybe a, Index) -&gt; Maybe b) -&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe b"><code>L.firstAs((maybeValue, index) =&gt; maybeValue, traversal, maybeData) ~&gt; maybeValue</code></a></h5>
<p><code>L.firstAs</code> goes lazily over the elements focused on by the given traversal,
applying the given function to each element, and returns the first
non-<code>undefined</code> value returned by the function.</p>
<pre><code class="hljs lang-js">L.firstAs(x =&gt; x &gt; 3 ? -x : undefined, L.elems, [3,1,4,1,5])
</code></pre>
<p><code>L.firstAs</code> operates lazily.  The user specified function is only applied to
elements until the first non-<code>undefined</code> value is returned and after that
<code>L.firstAs</code> returns without examining more elements.</p>
<p>Note that <code>L.firstAs</code> can be used to implement many other operations over
traversals such as finding an element matching a predicate and checking whether
all/any elements match a predicate.  For example, here is how you could
implement a for all predicate over traversals:</p>
<pre><code class="hljs lang-js">var all = R.curry((p, t, s) =&gt; !L.firstAs(x =&gt; p(x) ? undefined : true, t, s))
</code></pre>
<p>Now:</p>
<pre><code class="hljs lang-js">all(x =&gt; x &lt; 9,
    flatten,
    [[[1], 2], {y: 3}, [{l: 4, r: [5]}, {x: 6}]])
</code></pre>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-foldl-a-contents-https-github-com-calmm-js-partial-lenses-l-foldl-l-foldl-value-maybevalue-index-value-value-traversal-maybedata-value-l-foldl-l-foldl-r-maybe-a-index-r-r-ptraversal-s-a-maybe-s-r-"><a id="L-foldl"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-foldl">■</a> <a href="#L-foldl" title="L.foldl: ((r, Maybe a, Index) -&gt; r) -&gt; r -&gt; PTraversal s a -&gt; Maybe s -&gt; r"><code>L.foldl((value, maybeValue, index) =&gt; value, value, traversal, maybeData) ~&gt; value</code></a></h5>
<p><code>L.foldl</code> performs a fold from left over the elements focused on by the given
traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.foldl((x, y) =&gt; x + y, 0, L.elems, [1,2,3])
</code></pre>
<h5 id="-a-id-l-foldr-a-contents-https-github-com-calmm-js-partial-lenses-l-foldr-l-foldr-value-maybevalue-index-value-value-traversal-maybedata-value-l-foldr-l-foldr-r-maybe-a-index-r-r-ptraversal-s-a-maybe-s-r-"><a id="L-foldr"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-foldr">■</a> <a href="#L-foldr" title="L.foldr: ((r, Maybe a, Index) -&gt; r) -&gt; r -&gt; PTraversal s a -&gt; Maybe s -&gt; r"><code>L.foldr((value, maybeValue, index) =&gt; value, value, traversal, maybeData) ~&gt; value</code></a></h5>
<p><code>L.foldr</code> performs a fold from right over the elements focused on by the given
traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.foldr((x, y) =&gt; x * y, 1, L.elems, [1,2,3])
</code></pre>
<h5 id="-a-id-l-maximum-a-contents-https-github-com-calmm-js-partial-lenses-l-maximum-l-maximum-traversal-maybedata-maybevalue-l-maximum-l-maximum-ord-a-ptraversal-s-a-maybe-s-maybe-a-"><a id="L-maximum"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-maximum">■</a> <a href="#L-maximum" title="L.maximum: Ord a =&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.maximum(traversal, maybeData) ~&gt; maybeValue</code></a></h5>
<p><code>L.maximum</code> computes a maximum, according to the <code>&gt;</code> operator, of the optional
elements targeted by the traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.maximum(L.elems, [1,2,3])
</code></pre>
<h5 id="-a-id-l-minimum-a-contents-https-github-com-calmm-js-partial-lenses-l-minimum-l-minimum-traversal-maybedata-maybevalue-l-minimum-l-minimum-ord-a-ptraversal-s-a-maybe-s-maybe-a-"><a id="L-minimum"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-minimum">■</a> <a href="#L-minimum" title="L.minimum: Ord a =&gt; PTraversal s a -&gt; Maybe s -&gt; Maybe a"><code>L.minimum(traversal, maybeData) ~&gt; maybeValue</code></a></h5>
<p><code>L.minimum</code> computes a minimum, according to the <code>&lt;</code> operator, of the optional
elements targeted by the traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.minimum(L.elems, [1,2,3])
</code></pre>
<h5 id="-a-id-l-or-a-contents-https-github-com-calmm-js-partial-lenses-l-or-l-or-traversal-maybedata-boolean-l-or-l-or-ptraversal-s-boolean-boolean-"><a id="L-or"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-or">■</a> <a href="#L-or" title="L.or: PTraversal s Boolean -&gt; Boolean"><code>L.or(traversal, maybeData) ~&gt; boolean</code></a></h5>
<p><code>L.or</code> determines whether any of the elements focused on by the given traversal
is truthy.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.or(L.elems, [])
</code></pre>
<p>Note that <code>L.or</code> is equivalent to <a href="#L-any"><code>L.any(R.identity)</code></a>.  See
also: <a href="#L-and"><code>L.and</code></a>.</p>
<p><strong>WARNING: Lazy folds over traversals are experimental.</strong></p>
<h5 id="-a-id-l-product-a-contents-https-github-com-calmm-js-partial-lenses-product-l-product-traversal-maybedata-number-l-product-l-product-ptraversal-s-number-maybe-s-number-"><a id="L-product"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#-product">■</a> <a href="#L-product" title="L.product: PTraversal s Number -&gt; Maybe s -&gt; Number"><code>L.product(traversal, maybeData) ~&gt; number</code></a></h5>
<p><code>L.product</code> computes the product of the optional numbers targeted by the
traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.product(L.elems, [1,2,3])
</code></pre>
<h5 id="-a-id-l-sum-a-contents-https-github-com-calmm-js-partial-lenses-l-sum-l-sum-traversal-maybedata-number-l-sum-l-sum-ptraversal-s-number-maybe-s-number-"><a id="L-sum"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-sum">■</a> <a href="#L-sum" title="L.sum: PTraversal s Number -&gt; Maybe s -&gt; Number"><code>L.sum(traversal, maybeData) ~&gt; number</code></a></h5>
<p><code>L.sum</code> computes the sum of the optional numbers targeted by the traversal.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.sum(L.elems, [1,2,3])
</code></pre>
<h4 id="creating-new-traversals">Creating new traversals</h4>
<h5 id="-a-id-l-branch-a-contents-https-github-com-calmm-js-partial-lenses-l-branch-l-branch-prop-traversal-props-traversal-l-branch-l-branch-p1-ptraversal-s-a-pts-ptraversal-s-a-"><a id="L-branch"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-branch">■</a> <a href="#L-branch" title="L.branch: {p1: PTraversal s a, ...pts} -&gt; PTraversal s a"><code>L.branch({prop: traversal, ...props}) ~&gt; traversal</code></a></h5>
<p><code>L.branch</code> creates a new traversal from a given template object that specifies
how the new traversal should visit the properties of an object.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.collect(L.branch({first: L.elems, second: L.identity}),
          {first: [&quot;x&quot;], second: &quot;y&quot;})
</code></pre>
<p>Note that you can also compose <code>L.branch</code> with other optics.  For example, you
can compose with <a href="#L-pick"><code>L.pick</code></a> to create a traversal over specific
elements of an array:</p>
<pre><code class="hljs lang-js">L.modify([L.pick({x: 0, z: 2}),
          L.branch({x: L.identity, z: L.identity})],
         R.negate,
         [1, 2, 3])
</code></pre>
<p>See the <a href="#bst-traversal">BST traversal</a> section for a more meaningful example.</p>
<h4 id="traversals-and-combinators">Traversals and combinators</h4>
<h5 id="-a-id-l-elems-a-contents-https-github-com-calmm-js-partial-lenses-l-elems-l-elems-traversal-l-elems-l-elems-ptraversal-a-a-"><a id="L-elems"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-elems">■</a> <a href="#L-elems" title="L.elems: PTraversal [a] a"><code>L.elems ~&gt; traversal</code></a></h5>
<p><code>L.elems</code> is a traversal over the elements of an <a href="#array-like">array-like</a>
object.  When written through, <code>L.elems</code> always produces an <code>Array</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify([&quot;xs&quot;, L.elems, &quot;x&quot;], R.inc, {xs: [{x: 1}, {x: 2}]})
</code></pre>
<p>Just like with other optics operating on <a href="#array-like">array-like</a> objects, when
manipulating non-<code>Array</code> objects, <a href="#L-rewrite"><code>L.rewrite</code></a> can be used to
convert the result to the desired type, if necessary:</p>
<pre><code class="hljs lang-js">L.modify([L.rewrite(xs =&gt; Int8Array.from(xs)), L.elems],
         R.inc,
         Int8Array.from([-1,4,0,2,4]))
</code></pre>
<h5 id="-a-id-l-values-a-contents-https-github-com-calmm-js-partial-lenses-l-values-l-values-traversal-l-values-l-values-ptraversal-p-a-ps-a-"><a id="L-values"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-values">■</a> <a href="#L-values" title="L.values: PTraversal {p: a, ...ps} a"><code>L.values ~&gt; traversal</code></a></h5>
<p><code>L.values</code> is a traversal over the values of an <code>instanceof Object</code>.  When
written through, <code>L.values</code> always produces an <code>Object</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify(L.values, R.negate, {a: 1, b: 2, c: 3})
</code></pre>
<p>When manipulating objects with a non-<code>Object</code> constructor</p>
<pre><code class="hljs lang-js">function XYZ(x,y,z) {
  this.x = x
  this.y = y
  this.z = z
}

XYZ.prototype.norm = function () {
  return (this.x * this.x +
          this.y * this.y +
          this.z * this.z)
}
</code></pre>
<p><a href="#L-rewrite"><code>L.rewrite</code></a> can be used to convert the result to the desired type,
if necessary:</p>
<pre><code class="hljs lang-js">var objectTo = R.curry((C, o) =&gt; Object.assign(Object.create(C.prototype), o))

L.modify([L.rewrite(objectTo(XYZ)), L.values],
         R.negate,
         new XYZ(1,2,3))
</code></pre>
<h3 id="lenses">Lenses</h3>
<p>Lenses always have a single focus which can be <a href="#L-get">viewed</a> directly.</p>
<h4 id="operations-on-lenses">Operations on lenses</h4>
<h5 id="-a-id-l-get-a-contents-https-github-com-calmm-js-partial-lenses-l-get-l-get-lens-maybedata-maybevalue-l-get-l-get-plens-s-a-maybe-s-maybe-a-"><a id="L-get"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-get">■</a> <a href="#L-get" title="L.get: PLens s a -&gt; Maybe s -&gt; Maybe a"><code>L.get(lens, maybeData) ~&gt; maybeValue</code></a></h5>
<p><code>L.get</code> returns the focused element from a data structure.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(&quot;y&quot;, {x: 112, y: 101})
</code></pre>
<p>Note that <code>L.get</code> does not work on <a href="#traversals">traversals</a>.</p>
<h4 id="creating-new-lenses">Creating new lenses</h4>
<h5 id="-a-id-l-lens-a-contents-https-github-com-calmm-js-partial-lenses-l-lens-l-lens-maybedata-index-maybevalue-maybevalue-maybedata-index-maybedata-lens-l-lens-l-lens-maybe-s-index-maybe-a-maybe-a-maybe-s-index-maybe-s-plens-s-a-"><a id="L-lens"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-lens">■</a> <a href="#L-lens" title="L.lens: ((Maybe s, Index) -&gt; Maybe a) -&gt; ((Maybe a, Maybe s, Index) -&gt; Maybe s) -&gt; PLens s a"><code>L.lens((maybeData, index) =&gt; maybeValue, (maybeValue, maybeData, index) =&gt; maybeData) ~&gt; lens</code></a></h5>
<p><code>L.lens</code> creates a new primitive lens.  The first parameter is the <em>getter</em> and
the second parameter is the <em>setter</em>.  The setter takes two parameters: the
first is the value written and the second is the data structure to write into.</p>
<p>One should think twice before introducing a new primitive lens&mdash;most of the
combinators in this library have been introduced to reduce the need to write new
primitive lenses.  With that said, there are still valid reasons to create new
primitive lenses.  For example, here is a lens that we&#39;ve used in production,
written with the help of <a href="http://momentjs.com/">Moment.js</a>, to bidirectionally
convert a pair of <code>start</code> and <code>end</code> times to a duration:</p>
<pre><code class="hljs lang-js">var timesAsDuration = L.lens(
  ({start, end} = {}) =&gt; {
    if (undefined === start)
      return undefined
    if (undefined === end)
      return &quot;Infinity&quot;
    return moment.duration(moment(end).diff(moment(start))).toJSON()
  },
  (duration, {start = moment().toJSON()} = {}) =&gt; {
    if (undefined === duration || &quot;Infinity&quot; === duration) {
      return {start}
    } else {
      return {
        start,
        end: moment(start).add(moment.duration(duration)).toJSON()
      }
    }
  }
)
</code></pre>
<p>Now, for example:</p>
<pre><code class="hljs lang-js">L.get(timesAsDuration,
      {start: &quot;2016-12-07T09:39:02.451Z&quot;,
       end: moment(&quot;2016-12-07T09:39:02.451Z&quot;).add(10, &quot;hours&quot;).toISOString()})
</code></pre>
<pre><code class="hljs lang-js">L.set(timesAsDuration,
      &quot;PT10H&quot;,
      {start: &quot;2016-12-07T09:39:02.451Z&quot;,
       end: &quot;2016-12-07T09:39:02.451Z&quot;})
</code></pre>
<p>When composed with <a href="#L-pick"><code>L.pick</code></a>, to flexibly pick the <code>start</code> and <code>end</code>
times, the above can be adapted to work in a wide variety of cases.  However,
the above lens will never be added to this library, because it would require
adding dependency to <a href="http://momentjs.com/">Moment.js</a>.</p>
<p>See the <a href="#interfacing">Interfacing with Immutable.js</a> section for another
example of using <code>L.lens</code>.</p>
<h4 id="computing-derived-props">Computing derived props</h4>
<h5 id="-a-id-l-augment-a-contents-https-github-com-calmm-js-partial-lenses-l-augment-l-augment-prop-object-value-props-lens-l-augment-l-augment-p1-o-a1-ps-plens-o-o-p1-a1-ps-"><a id="L-augment"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-augment">■</a> <a href="#L-augment" title="L.augment: {p1: o -&gt; a1, ...ps} -&gt; PLens {...o} {...o, p1: a1, ...ps}"><code>L.augment({prop: object =&gt; value, ...props}) ~&gt; lens</code></a></h5>
<p><code>L.augment</code> is given a template of functions to compute new properties.  When
not viewing or setting a defined object, the result is <code>undefined</code>.  When
viewing a defined object, the object is extended with the computed properties.
When set with a defined object, the extended properties are removed.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.modify(L.augment({y: r =&gt; r.x + 1}),
         r =&gt; ({x: r.x + r.y, y: 2, z: r.x - r.y}),
         {x: 1})
</code></pre>
<h4 id="enforcing-invariants">Enforcing invariants</h4>
<h5 id="-a-id-l-defaults-a-contents-https-github-com-calmm-js-partial-lenses-l-defaults-l-defaults-valuein-lens-l-defaults-l-defaults-s-plens-s-s-"><a id="L-defaults"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-defaults">■</a> <a href="#L-defaults" title="L.defaults: s -&gt; PLens s s"><code>L.defaults(valueIn) ~&gt; lens</code></a></h5>
<p><code>L.defaults</code> is used to specify a default context or value for an element in
case it is missing.  When set with the default value, the effect is to remove
the element.  This can be useful for both making partial lenses with propagating
removal and for avoiding having to check for and provide default values
elsewhere.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get([&quot;items&quot;, L.defaults([])], {})
</code></pre>
<pre><code class="hljs lang-js">L.get([&quot;items&quot;, L.defaults([])], {items: [1, 2, 3]})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;items&quot;, L.defaults([])], [], {items: [1, 2, 3]})
</code></pre>
<p>Note that <code>L.defaults(valueIn)</code> is equivalent
to <a href="#L-replace"><code>L.replace(undefined, valueIn)</code></a>.</p>
<h5 id="-a-id-l-define-a-contents-https-github-com-calmm-js-partial-lenses-l-define-l-define-value-lens-l-define-l-define-s-plens-s-s-"><a id="L-define"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-define">■</a> <a href="#L-define" title="L.define: s -&gt; PLens s s"><code>L.define(value) ~&gt; lens</code></a></h5>
<p><code>L.define</code> is used to specify a value to act as both the default value and the
required value for an element.</p>
<pre><code class="hljs lang-js">L.get([&quot;x&quot;, L.define(null)], {y: 10})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;x&quot;, L.define(null)], undefined, {y: 10})
</code></pre>
<p>Note that <code>L.define(value)</code> is equivalent to <code>[L.required(value),
L.defaults(value)]</code>.</p>
<h5 id="-a-id-l-normalize-a-contents-https-github-com-calmm-js-partial-lenses-l-normalize-l-normalize-value-index-maybevalue-lens-l-normalize-l-normalize-s-index-maybe-s-plens-s-s-"><a id="L-normalize"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-normalize">■</a> <a href="#L-normalize" title="L.normalize: ((s, Index) -&gt; Maybe s) -&gt; PLens s s"><code>L.normalize((value, index) =&gt; maybeValue) ~&gt; lens</code></a></h5>
<p><code>L.normalize</code> maps the value with same given transform when viewed and set and
implicitly maps <code>undefined</code> to <code>undefined</code>.</p>
<p>One use case for <code>normalize</code> is to make it easy to determine whether, after a
change, the data has actually changed.  By keeping the data normalized, a
simple <a href="http://ramdajs.com/docs/#equals"><code>R.equals</code></a> comparison will do.</p>
<p>Note that the difference between <code>L.normalize</code> and <a href="#L-rewrite"><code>L.rewrite</code></a> is
that <code>L.normalize</code> applies the transform in both directions
while <a href="#L-rewrite"><code>L.rewrite</code></a> only applies the transform when writing.</p>
<h5 id="-a-id-l-required-a-contents-https-github-com-calmm-js-partial-lenses-l-required-l-required-valueout-lens-l-required-l-required-s-plens-s-s-"><a id="L-required"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-required">■</a> <a href="#L-required" title="L.required: s -&gt; PLens s s"><code>L.required(valueOut) ~&gt; lens</code></a></h5>
<p><code>L.required</code> is used to specify that an element is not to be removed; in case it
is removed, the given value will be substituted instead.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.remove([&quot;items&quot;, 0], {items: [1]})
</code></pre>
<pre><code class="hljs lang-js">L.remove([L.required({}), &quot;items&quot;, 0], {items: [1]})
</code></pre>
<pre><code class="hljs lang-js">L.remove([&quot;items&quot;, L.required([]), 0], {items: [1]})
</code></pre>
<p>Note that <code>L.required(valueOut)</code> is equivalent
to <a href="#L-replace"><code>L.replace(valueOut, undefined)</code></a>.</p>
<h5 id="-a-id-l-rewrite-a-contents-https-github-com-calmm-js-partial-lenses-l-rewrite-l-rewrite-valueout-index-maybevalueout-lens-l-rewrite-l-rewrite-s-index-maybe-s-plens-s-s-"><a id="L-rewrite"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-rewrite">■</a> <a href="#L-rewrite" title="L.rewrite: ((s, Index) -&gt; Maybe s) -&gt; PLens s s"><code>L.rewrite((valueOut, index) =&gt; maybeValueOut) ~&gt; lens</code></a></h5>
<p><code>L.rewrite</code> maps the value with the given transform when set and implicitly maps
<code>undefined</code> to <code>undefined</code>.  One use case for <code>rewrite</code> is to re-establish data
structure invariants after changes.</p>
<p>Note that the difference between <a href="#L-normalize"><code>L.normalize</code></a> and <code>L.rewrite</code>
is that <a href="#L-normalize"><code>L.normalize</code></a> applies the transform in both directions
while <code>L.rewrite</code> only applies the transform when writing.</p>
<p>See the <a href="#bst-as-a-lens">BST as a lens</a> section for a meaningful example.</p>
<h4 id="-a-id-array-like-a-lensing-array-like-objects"><a id="array-like"></a> Lensing array-like objects</h4>
<p>Objects that have a non-negative integer <code>length</code> and strings, which are not
considered <code>Object</code> instances in JavaScript, are considered <em>array-like</em> objects
by partial optics.</p>
<p>When writing a defined value through an optic that operates on array-like
objects, the result is always an <code>Array</code>.  For example:</p>
<pre><code class="hljs lang-js">L.set(1, &quot;a&quot;, &quot;LoLa&quot;)
</code></pre>
<p>It may seem like the result should be of the same type as the object being
manipulated, but that is problematic, because the focus of a <em>partial</em> optic is
always optional.  Instead, when manipulating strings or array-like non-<code>Array</code>
objects, <a href="#L-rewrite"><code>L.rewrite</code></a> can be used to convert the result to the
desired type, if necessary.  For example:</p>
<pre><code class="hljs lang-js">L.set([L.rewrite(R.join(&quot;&quot;)), 1], &quot;a&quot;, &quot;LoLa&quot;)
</code></pre>
<h5 id="-a-id-l-append-a-contents-https-github-com-calmm-js-partial-lenses-l-append-l-append-lens-l-append-l-append-plens-a-a-"><a id="L-append"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-append">■</a> <a href="#L-append" title="L.append: PLens [a] a"><code>L.append ~&gt; lens</code></a></h5>
<p><code>L.append</code> is a write-only lens that can be used to append values to
an <a href="#array-like">array-like</a> object.  The view of <code>L.append</code> is always
<code>undefined</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.append, [&quot;x&quot;])
</code></pre>
<pre><code class="hljs lang-js">L.set(L.append, &quot;x&quot;, undefined)
</code></pre>
<pre><code class="hljs lang-js">L.set(L.append, &quot;x&quot;, [&quot;z&quot;, &quot;y&quot;])
</code></pre>
<p>Note that <code>L.append</code> is equivalent to <a href="#L-index"><code>L.index(i)</code></a> with the index
<code>i</code> set to the length of the focused array or 0 in case the focus is not a
defined array.</p>
<h5 id="-a-id-l-filter-a-contents-https-github-com-calmm-js-partial-lenses-l-filter-l-filter-value-index-testable-lens-l-filter-l-filter-a-index-boolean-plens-a-a-"><a id="L-filter"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-filter">■</a> <a href="#L-filter" title="L.filter: ((a, Index) -&gt; Boolean) -&gt; PLens [a] [a]"><code>L.filter((value, index) =&gt; testable) ~&gt; lens</code></a></h5>
<p><code>L.filter</code> operates on <a href="#array-like">array-like</a> objects.  When not viewing an
array-like object, the result is <code>undefined</code>.  When viewing an array-like
object, only elements matching the given predicate will be returned.  When set,
the resulting array will be formed by concatenating the elements of the set
array-like object and the elements of the complement of the filtered focus.  If
the resulting array would be empty, the whole result will be <code>undefined</code>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.set(L.filter(x =&gt; x &lt;= &quot;2&quot;), &quot;abcd&quot;, &quot;3141592&quot;)
</code></pre>
<p><strong>NOTE</strong>: If you are merely modifying a data structure, and don&#39;t need to limit
yourself to lenses, consider using the <a href="#L-elems"><code>L.elems</code></a> traversal composed
with <a href="#L-when"><code>L.when</code></a>.</p>
<p>An alternative design for filter could implement a smarter algorithm to combine
arrays when set.  For example, an algorithm based
on <a href="https://en.wikipedia.org/wiki/Edit_distance">edit distance</a> could be used to
maintain relative order of elements.  While this would not be difficult to
implement, it doesn&#39;t seem to make sense, because in most cases use
of <a href="#L-normalize"><code>L.normalize</code></a> or <a href="#L-rewrite"><code>L.rewrite</code></a> would be
preferable.  Also, the <a href="#L-elems"><code>L.elems</code></a> traversal composed
with <a href="#L-when"><code>L.when</code></a> will retain order of elements.</p>
<h5 id="-a-id-l-find-a-contents-https-github-com-calmm-js-partial-lenses-l-find-l-find-value-index-testable-lens-l-find-l-find-a-index-boolean-plens-a-a-"><a id="L-find"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-find">■</a> <a href="#L-find" title="L.find: ((a, Index) -&gt; Boolean) -&gt; PLens [a] a"><code>L.find((value, index) =&gt; testable) ~&gt; lens</code></a></h5>
<p><code>L.find</code> operates on <a href="#array-like">array-like</a> objects
like <a href="#L-index"><code>L.index</code></a>, but the index to be viewed is determined by finding
the first element from the focus that matches the given predicate.  When no
matching element is found the effect is same as with <a href="#L-append"><code>L.append</code></a>.</p>
<pre><code class="hljs lang-js">L.remove(L.find(x =&gt; x &lt;= 2), [3,1,4,1,5,9,2])
</code></pre>
<h5 id="-a-id-l-findwith-a-contents-https-github-com-calmm-js-partial-lenses-l-findwith-l-findwith-lenses-lens-l-findwith-l-findwith-plens-s-s1-plens-sn-a-plens-s-a-"><a id="L-findWith"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-findWith">■</a> <a href="#L-findWith" title="L.findWith: (PLens s s1, ...PLens sN a) -&gt; PLens [s] a"><code>L.findWith(...lenses) ~&gt; lens</code></a></h5>
<p><code>L.findWith(...lenses)</code> chooses an index from an <a href="#array-like">array-like</a>
object through which the given lens, <a href="#L-compose"><code>[...lenses]</code></a>, focuses on a
defined item and then returns a lens that focuses on that item.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.findWith(&quot;x&quot;), [{z: 6}, {x: 9}, {y: 6}])
</code></pre>
<pre><code class="hljs lang-js">L.set(L.findWith(&quot;x&quot;), 3, [{z: 6}, {x: 9}, {y: 6}])
</code></pre>
<h5 id="-a-id-l-index-a-contents-https-github-com-calmm-js-partial-lenses-l-index-l-index-elemindex-lens-l-index-l-index-integer-plens-a-a-or-elemindex-"><a id="L-index"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-index">■</a> <a href="#L-index" title="L.index: Integer -&gt; PLens [a] a"><code>L.index(elemIndex) ~&gt; lens</code></a> or <code>elemIndex</code></h5>
<p><code>L.index(elemIndex)</code> or just <code>elemIndex</code> focuses on the element at specified
index of an <a href="#array-like">array-like</a> object.</p>
<ul>
<li>When not viewing an index with a defined element, the result is <code>undefined</code>.</li>
<li>When setting to <code>undefined</code>, the element is removed from the resulting array,
shifting all higher indices down by one.  If the result would be an empty
array, the whole result will be <code>undefined</code>.</li>
<li>When setting a defined value to an index that is higher than the length of the
array-like object, the missing elements will be filled with <code>undefined</code>.</li>
</ul>
<p>For example:</p>
<pre><code class="hljs lang-js">L.set(2, &quot;z&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;c&quot;])
</code></pre>
<p><strong>NOTE:</strong> There is a gotcha related to removing elements from array-like
objects.  Namely, when the last element is removed, the result is <code>undefined</code>
rather than an empty array.  This is by design, because this allows the removal
to propagate upwards.  It is not uncommon, however, to have cases where removing
the last element from an array-like object must not remove the array itself.
Consider the following examples without <a href="#L-required"><code>L.required([])</code></a>:</p>
<pre><code class="hljs lang-js">L.remove(0, [&quot;a&quot;, &quot;b&quot;])
</code></pre>
<pre><code class="hljs lang-js">L.remove(0, [&quot;b&quot;])
</code></pre>
<pre><code class="hljs lang-js">L.remove([&quot;elems&quot;, 0], {elems: [&quot;b&quot;], some: &quot;thing&quot;})
</code></pre>
<p>Then consider the same examples with <a href="#L-required"><code>L.required([])</code></a>:</p>
<pre><code class="hljs lang-js">L.remove([L.required([]), 0], [&quot;a&quot;, &quot;b&quot;])
</code></pre>
<pre><code class="hljs lang-js">L.remove([L.required([]), 0], [&quot;b&quot;])
</code></pre>
<pre><code class="hljs lang-js">L.remove([&quot;elems&quot;, L.required([]), 0], {elems: [&quot;b&quot;], some: &quot;thing&quot;})
</code></pre>
<p>There is a related gotcha with <a href="#L-required"><code>L.required</code></a>.  Consider the
following example:</p>
<pre><code class="hljs lang-js">L.remove(L.required([]), [])
</code></pre>
<pre><code class="hljs lang-js">L.get(L.required([]), [])
</code></pre>
<p>In other words, <a href="#L-required"><code>L.required</code></a> works in both directions.  Thanks to
the handling of <code>undefined</code> within partial lenses, this is often not a problem,
but sometimes you need the &quot;default&quot; value both ways.  In that case you can
use <a href="#L-define"><code>L.define</code></a>.</p>
<h5 id="-a-id-l-slice-a-contents-https-github-com-calmm-js-partial-lenses-l-slice-l-slice-maybebegin-maybeend-lens-l-slice-l-slice-maybe-integer-maybe-integer-plens-a-a-"><a id="L-slice"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-slice">■</a> <a href="#L-slice" title="L.slice: Maybe Integer -&gt; Maybe Integer -&gt; PLens [a] [a]"><code>L.slice(maybeBegin, maybeEnd) ~&gt; lens</code></a></h5>
<p><code>L.slice</code> focuses on a specified range of elements of
an <a href="#array-like">array-like</a> object.  The range is determined like with the
standard
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"><code>slice</code></a> method
of arrays, basically</p>
<ul>
<li>non-negative values are relative to the beginning of the array-like object,</li>
<li>negative values are relative to the end of the array-like object, and</li>
<li><code>undefined</code> gives the defaults: 0 for the begin and length for the end.</li>
</ul>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.slice(1, -1), [1,2,3,4])
</code></pre>
<pre><code class="hljs lang-js">L.set(L.slice(-2, undefined), [0], [1,2,3,4])
</code></pre>
<h4 id="lensing-objects">Lensing objects</h4>
<h5 id="-a-id-l-prop-a-contents-https-github-com-calmm-js-partial-lenses-l-prop-l-prop-propname-lens-l-prop-l-prop-p-a-plens-p-a-ps-a-or-propname-"><a id="L-prop"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-prop">■</a> <a href="#L-prop" title="L.prop: (p: a) -&gt; PLens {p: a, ...ps} a"><code>L.prop(propName) ~&gt; lens</code></a> or <code>propName</code></h5>
<p><code>L.prop(propName)</code> or just <code>propName</code> focuses on the specified object property.</p>
<ul>
<li>When not viewing a defined object property, the result is <code>undefined</code>.</li>
<li>When writing to a property, the result is always an <code>Object</code>.</li>
<li>When setting property to <code>undefined</code>, the property is removed from the result.
If the result would be an empty object, the whole result will be <code>undefined</code>.</li>
</ul>
<p>When setting or removing properties, the order of keys is preserved.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(&quot;y&quot;, {x: 1, y: 2, z: 3})
</code></pre>
<pre><code class="hljs lang-js">L.set(&quot;y&quot;, -2, {x: 1, y: 2, z: 3})
</code></pre>
<p>When manipulating objects whose constructor is not
<code>Object</code>, <a href="#L-rewrite"><code>L.rewrite</code></a> can be used to convert the result to the
desired type, if necessary:</p>
<pre><code class="hljs lang-js">L.set([L.rewrite(objectTo(XYZ)), &quot;z&quot;], 3, new XYZ(3,1,4))
</code></pre>
<h5 id="-a-id-l-props-a-contents-https-github-com-calmm-js-partial-lenses-l-props-l-props-propnames-lens-l-props-l-props-p1-a1-ps-plens-p1-a1-ps-o-p1-a1-ps-"><a id="L-props"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-props">■</a> <a href="#L-props" title="L.props: (p1: a1, ...ps) -&gt; PLens {p1: a1, ...ps, ...o} {p1: a1, ...ps}"><code>L.props(...propNames) ~&gt; lens</code></a></h5>
<p><code>L.props</code> focuses on a subset of properties of an object, allowing one to treat
the subset of properties as a unit.  The view of <code>L.props</code> is <code>undefined</code> when
none of the properties is defined.  Otherwise the view is an object containing a
subset of the properties.  Setting through <code>L.props</code> updates the whole subset of
properties, which means that any missing properties are removed if they did
exists previously.  When set, any extra properties are ignored.</p>
<pre><code class="hljs lang-js">L.set(L.props(&quot;x&quot;, &quot;y&quot;), {x: 4}, {x: 1, y: 2, z: 3})
</code></pre>
<p>Note that <code>L.props(k1, ..., kN)</code> is equivalent to <a href="#L-pick"><code>L.pick({[k1]: k1, ..., [kN]:
kN})</code></a>.</p>
<h5 id="-a-id-l-removable-a-contents-https-github-com-calmm-js-partial-lenses-l-removable-l-removable-propnames-lens-l-removable-l-removable-p1-a1-ps-plens-p1-a1-ps-o-p1-a1-ps-o-"><a id="L-removable"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-removable">■</a> <a href="#L-removable" title="L.removable (p1: a1, ...ps) -&gt; PLens {p1: a1, ...ps, ...o} {p1: a1, ...ps, ...o}"><code>L.removable(...propNames) ~&gt; lens</code></a></h5>
<p><code>L.removable</code> creates a lens that, when written through, replaces the whole
result with <code>undefined</code> if none of the given properties is defined in the
written object.  <code>L.removable</code> is designed for making removal propagate through
objects.</p>
<p>Contrast the following examples:</p>
<pre><code class="hljs lang-js">L.remove(&quot;x&quot;, {x: 1, y: 2})
</code></pre>
<pre><code class="hljs lang-js">L.remove([L.removable(&quot;x&quot;), &quot;x&quot;], {x: 1, y: 2})
</code></pre>
<p>Note that <code>L.removable(...ps)</code> is roughly equivalent
to
<a href="#L-rewrite"><code>rewrite(y =&gt; y instanceof Object &amp;&amp; !R.any(p =&gt; R.has(p, y), ps) ? undefined : y)</code></a>.</p>
<p>Also note that, in a composition, <code>L.removable</code> is likely preceded
by <a href="#L-valueOr"><code>L.valueOr</code></a> (or <a href="#L-defaults"><code>L.defaults</code></a>) like in
the <a href="#tutorial">tutorial</a> example.  In such a pair, the preceding lens gives a
default value when reading through the lens, allowing one to use such a lens to
insert new objects.  The following lens then specifies that removing the then
focused property (or properties) should remove the whole object.  In cases where
the shape of the incoming object is know, <a href="#L-defaults"><code>L.defaults</code></a> can
replace such a pair.</p>
<h4 id="providing-defaults">Providing defaults</h4>
<h5 id="-a-id-l-valueor-a-contents-https-github-com-calmm-js-partial-lenses-l-valueor-l-valueor-valueout-lens-l-valueor-l-valueor-s-plens-s-s-"><a id="L-valueOr"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-valueOr">■</a> <a href="#L-valueOr" title="L.valueOr: s -&gt; PLens s s"><code>L.valueOr(valueOut) ~&gt; lens</code></a></h5>
<p><code>L.valueOr</code> is an asymmetric lens used to specify a default value in case the
focus is <code>undefined</code> or <code>null</code>.  When set, <code>L.valueOr</code> behaves like the identity
lens.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.valueOr(0), null)
</code></pre>
<pre><code class="hljs lang-js">L.set(L.valueOr(0), 0, 1)
</code></pre>
<pre><code class="hljs lang-js">L.remove(L.valueOr(0), 1)
</code></pre>
<h4 id="adapting-to-data">Adapting to data</h4>
<h5 id="-a-id-l-orelse-a-contents-https-github-com-calmm-js-partial-lenses-l-orelse-l-orelse-backuplens-primarylens-lens-l-orelse-l-orelse-plens-s-a-plens-s-a-plens-s-a-"><a id="L-orElse"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-orElse">■</a> <a href="#L-orElse" title="L.orElse: (PLens s a, PLens s a) -&gt; PLens s a"><code>L.orElse(backupLens, primaryLens) ~&gt; lens</code></a></h5>
<p><code>L.orElse(backupLens, primaryLens)</code> acts like <code>primaryLens</code> when its view is not
<code>undefined</code> and otherwise like <code>backupLens</code>.  You can use <code>L.orElse</code> on its own
with <a href="http://ramdajs.com/docs/#reduceRight"><code>R.reduceRight</code></a>
(and <a href="http://ramdajs.com/docs/#reduce"><code>R.reduce</code></a>) to create an associative
choice over lenses or use <code>L.orElse</code> to specify a default or backup lens
for <a href="#L-choice"><code>L.choice</code></a>, for example.</p>
<h4 id="read-only-mapping">Read-only mapping</h4>
<h5 id="-a-id-l-just-a-contents-https-github-com-calmm-js-partial-lenses-l-just-l-just-maybevalue-lens-l-just-l-just-maybe-a-plens-s-a-"><a id="L-just"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-just">■</a> <del><a href="#L-just" title="L.just: Maybe a -&gt; PLens s a"><code>L.just(maybeValue) ~&gt; lens</code></a></del></h5>
<p><strong>WARNING: <code>L.just</code> is obsolete, just use e.g. <a href="http://ramdajs.com/docs/#always"><code>R.always</code></a>.</strong></p>
<p><code>L.just</code> returns a read-only lens whose view is always the given value.  In
other words, for all <code>x</code>, <code>y</code> and <code>z</code>:</p>
<pre><code class="hljs lang-jsx">   L.get(L.just(z), x) = z
L.set(L.just(z), y, x) = x
</code></pre>
<p>Note that <code>L.just(x)</code> is equivalent to <a href="#L-to"><code>L.to(R.always(x))</code></a>.</p>
<p><code>L.just</code> can be seen as the unit function of the monad formed
with <a href="#L-chain"><code>L.chain</code></a>.</p>
<h5 id="-a-id-l-to-a-contents-https-github-com-calmm-js-partial-lenses-l-to-l-to-maybevalue-index-maybevalue-lens-l-to-l-to-a-index-b-plens-a-b-"><a id="L-to"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-to">■</a> <del><a href="#L-to" title="L.to: ((a, Index) -&gt; b) -&gt; PLens a b"><code>L.to((maybeValue, index) =&gt; maybeValue) ~&gt; lens</code></a></del></h5>
<p><strong>WARNING: <code>L.to</code> is obsolete, you can directly <a href="#L-compose"><code>L.compose</code></a> plain functions with optics.</strong></p>
<p><code>L.to</code> creates a read-only lens whose view is determined by the given function.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get([&quot;x&quot;, L.to(x =&gt; x + 1)], {x: 1})
</code></pre>
<pre><code class="hljs lang-js">L.set([&quot;x&quot;, L.to(x =&gt; x + 1)], 3, {x: 1})
</code></pre>
<h4 id="transforming-data">Transforming data</h4>
<h5 id="-a-id-l-pick-a-contents-https-github-com-calmm-js-partial-lenses-l-pick-l-pick-prop-lens-props-lens-l-pick-l-pick-p1-plens-s-a1-pls-plens-s-p1-a1-pls-"><a id="L-pick"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-pick">■</a> <a href="#L-pick" title="L.pick: {p1: PLens s a1, ...pls} -&gt; PLens s {p1: a1, ...pls}"><code>L.pick({prop: lens, ...props}) ~&gt; lens</code></a></h5>
<p><code>L.pick</code> creates a lens out of the given object template of lenses and allows
one to pick apart a data structure and then put it back together.  When viewed,
an object is created, whose properties are obtained by viewing through the
lenses of the template.  When set with an object, the properties of the object
are set to the context via the lenses of the template.  <code>undefined</code> is treated
as the equivalent of empty or non-existent in both directions.</p>
<p>For example, let&#39;s say we need to deal with data and schema in need of some
semantic restructuring:</p>
<pre><code class="hljs lang-js">var sampleFlat = {px: 1, py: 2, vx: 1.0, vy: 0.0}
</code></pre>
<p>We can use <code>L.pick</code> to create lenses to pick apart the data and put it back
together into a more meaningful structure:</p>
<pre><code class="hljs lang-js">var asVec = prefix =&gt; L.pick({x: prefix + &quot;x&quot;, y: prefix + &quot;y&quot;})
var sanitize = L.pick({pos: asVec(&quot;p&quot;), vel: asVec(&quot;v&quot;)})
</code></pre>
<p>We now have a better structured view of the data:</p>
<pre><code class="hljs lang-js">L.get(sanitize, sampleFlat)
</code></pre>
<p>That works in both directions:</p>
<pre><code class="hljs lang-js">L.modify([sanitize, &quot;pos&quot;, &quot;x&quot;], R.add(5), sampleFlat)
</code></pre>
<p><strong>NOTE:</strong> In order for a lens created with <code>L.pick</code> to work in a predictable
manner, the given lenses must operate on independent parts of the data
structure.  As a trivial example, in <code>L.pick({x: &quot;same&quot;, y: &quot;same&quot;})</code> both of
the resulting object properties, <code>x</code> and <code>y</code>, address the same property of the
underlying object, so writing through the lens will give unpredictable results.</p>
<p>Note that, when set, <code>L.pick</code> simply ignores any properties that the given
template doesn&#39;t mention.  Also note that the underlying data structure need not
be an object.</p>
<h5 id="-a-id-l-replace-a-contents-https-github-com-calmm-js-partial-lenses-l-replace-l-replace-maybevaluein-maybevalueout-lens-l-replace-l-replace-maybe-s-maybe-s-plens-s-s-"><a id="L-replace"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-replace">■</a> <a href="#L-replace" title="L.replace: Maybe s -&gt; Maybe s -&gt; PLens s s"><code>L.replace(maybeValueIn, maybeValueOut) ~&gt; lens</code></a></h5>
<p><code>L.replace(maybeValueIn, maybeValueOut)</code>, when viewed, replaces the value
<code>maybeValueIn</code> with <code>maybeValueOut</code> and vice versa when set.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.replace(1, 2), 1)
</code></pre>
<pre><code class="hljs lang-js">L.set(L.replace(1, 2), 2, 0)
</code></pre>
<p>The main use case for <code>replace</code> is to handle optional and required properties
and elements.  In most cases, rather than using <code>replace</code>, you will make
selective use of <a href="#L-defaults"><code>defaults</code></a>, <a href="#L-required"><code>required</code></a>
and <a href="#L-define"><code>define</code></a>.</p>
<h3 id="isomorphisms">Isomorphisms</h3>
<p>The focus of an isomorphism is the whole data structure rather than a part of
it.  Furthermore, an isomorphism can be <a href="#L-inverse">inverted</a>.  More
specifically, a lens, <code>iso</code>, is an isomorphism iff the following equations hold
for all <code>x</code> and <code>y</code> in the domain and range, respectively, of the lens:</p>
<pre><code class="hljs lang-jsx">L.set(iso, L.get(iso, x), undefined) = x
L.get(iso, L.set(iso, y, undefined)) = y
</code></pre>
<p>The above equations mean that <code>x =&gt; L.get(iso, x)</code> and <code>y =&gt; L.set(iso, y,
undefined)</code> are inverses of each other.</p>
<h4 id="operations-on-isomorphisms">Operations on isomorphisms</h4>
<h5 id="-a-id-l-getinverse-a-contents-https-github-com-calmm-js-partial-lenses-l-getinverse-l-getinverse-isomorphism-maybedata-maybedata-l-getinverse-l-getinverse-piso-a-b-maybe-b-maybe-a-"><a id="L-getInverse"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-getInverse">■</a> <a href="#L-getInverse" title="L.getInverse: PIso a b -&gt; Maybe b -&gt; Maybe a"><code>L.getInverse(isomorphism, maybeData) ~&gt; maybeData</code></a></h5>
<p><code>L.getInverse</code> views through an isomorphism in the inverse direction.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var numeric = f =&gt; x =&gt; typeof x === &quot;number&quot; ? f(x) : undefined
var offBy1 = L.iso(numeric(R.inc), numeric(R.dec))
L.getInverse(offBy1, 1)
</code></pre>
<p>Note that <code>L.getInverse(iso, data)</code> is equivalent
to <a href="#L-set"><code>L.set(iso, data, undefined)</code></a>.</p>
<p>Also note that, while <code>L.getInverse</code> makes most sense when used with an
isomorphism, it is valid to use <code>L.getInverse</code> with <em>partial</em> lenses in general.
Doing so essentially constructs a minimal data structure that contains the given
value.  For example:</p>
<pre><code class="hljs lang-js">L.getInverse(&quot;meaning&quot;, 42)
</code></pre>
<h4 id="creating-new-isomorphisms">Creating new isomorphisms</h4>
<h5 id="-a-id-l-iso-a-contents-https-github-com-calmm-js-partial-lenses-l-iso-l-iso-maybedata-maybevalue-maybevalue-maybedata-isomorphism-l-iso-l-iso-maybe-s-maybe-a-maybe-a-maybe-s-piso-s-a-"><a id="L-iso"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-iso">■</a> <a href="#L-iso" title="L.iso: (Maybe s -&gt; Maybe a) -&gt; (Maybe a -&gt; Maybe s) -&gt; PIso s a"><code>L.iso(maybeData =&gt; maybeValue, maybeValue =&gt; maybeData) ~&gt; isomorphism</code></a></h5>
<p><code>L.iso</code> creates a new primitive isomorphism.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var negate = L.iso(numeric(R.negate), numeric(R.negate))
L.get([negate, L.inverse(negate)], 112)
</code></pre>
<h4 id="isomorphisms-and-combinators">Isomorphisms and combinators</h4>
<h5 id="-a-id-l-identity-a-contents-https-github-com-calmm-js-partial-lenses-l-identity-l-identity-isomorphism-l-identity-l-identity-piso-s-s-"><a id="L-identity"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-identity">■</a> <a href="#L-identity" title="L.identity: PIso s s"><code>L.identity ~&gt; isomorphism</code></a></h5>
<p><code>L.identity</code> is the identity element of lens composition and also the identity
isomorphism.  The following equations characterize <code>L.identity</code>:</p>
<pre><code class="hljs lang-jsx">      L.get(L.identity, x) = x
L.modify(L.identity, f, x) = f(x)
  L.compose(L.identity, l) = l
  L.compose(l, L.identity) = l
</code></pre>
<h5 id="-a-id-l-inverse-a-contents-https-github-com-calmm-js-partial-lenses-l-inverse-l-inverse-isomorphism-isomorphism-l-inverse-l-inverse-piso-a-b-piso-b-a-"><a id="L-inverse"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses#L-inverse">■</a> <a href="#L-inverse" title="L.inverse: PIso a b -&gt; PIso b a"><code>L.inverse(isomorphism) ~&gt; isomorphism</code></a></h5>
<p><code>L.inverse</code> returns the inverse of the given isomorphism.  Note that this
operation only makes sense on isomorphisms.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">L.get(L.inverse(offBy1), 1)
</code></pre>
<h2 id="examples">Examples</h2>
<p>Note that if you are new to lenses, then you probably want to start with
the <a href="#tutorial">tutorial</a>.</p>
<h3 id="an-array-of-ids-as-boolean-flags">An array of ids as boolean flags</h3>
<p>A case that we have run into multiple times is where we have an array of
constant strings such as</p>
<pre><code class="hljs lang-js">var sampleFlags = [&quot;id-19&quot;, &quot;id-76&quot;]
</code></pre>
<p>that we wish to manipulate as if it was a collection of boolean flags.  Here is
a parameterized lens that does just that:</p>
<pre><code class="hljs lang-js">var flag = id =&gt; [L.normalize(R.sortBy(R.identity)),
                    L.find(R.equals(id)),
                    L.replace(undefined, false),
                    L.replace(id, true)]
</code></pre>
<p>Now we can treat individual constants as boolean flags:</p>
<pre><code class="hljs lang-js">L.get(flag(&quot;id-69&quot;), sampleFlags)
</code></pre>
<pre><code class="hljs lang-js">L.get(flag(&quot;id-76&quot;), sampleFlags)
</code></pre>
<p>In both directions:</p>
<pre><code class="hljs lang-js">L.set(flag(&quot;id-69&quot;), true, sampleFlags)
</code></pre>
<pre><code class="hljs lang-js">L.set(flag(&quot;id-76&quot;), false, sampleFlags)
</code></pre>
<h3 id="bst-as-a-lens">BST as a lens</h3>
<p>Binary search trees might initially seem to be outside the scope of definable
lenses.  However, given basic BST operations, one could easily wrap them as a
primitive partial lens.  But could we leverage lens combinators to build a BST
lens more compositionally?  We can.  The <a href="#L-choose"><code>L.choose</code></a> combinator
allows for dynamic construction of lenses based on examining the data structure
being manipulated.  Inside <a href="#L-choose"><code>L.choose</code></a> we can write the ordinary BST
logic to pick the correct branch based on the key in the currently examined node
and the key that we are looking for.  So, here is our first attempt at a BST
lens:</p>
<pre><code class="hljs lang-js">var searchAttempt = key =&gt; L.lazy(rec =&gt; {
  const smaller = [&quot;smaller&quot;, rec]
  const greater = [&quot;greater&quot;, rec]
  const found = L.defaults({key})
  return L.choose(n =&gt; {
    if (!n || key === n.key)
      return found
    return key &lt; n.key ? smaller : greater
  })
})

var valueOfAttempt = key =&gt; [searchAttempt(key), &quot;value&quot;]
</code></pre>
<p>Note that we also make use of the <a href="#L-lazy"><code>L.lazy</code></a> combinator to create a
recursive lens with a cyclic representation.</p>
<p>This actually works to a degree.  We can use the <code>valueOfAttempt</code> lens
constructor to build a binary tree.  Here is a little helper to build a tree
from pairs:</p>
<pre><code class="hljs lang-js">var fromPairs =
  R.reduce((t, [k, v]) =&gt; L.set(valueOfAttempt(k), v, t), undefined)
</code></pre>
<p>Now:</p>
<pre><code class="hljs lang-js">var sampleBST = fromPairs([[3, &quot;g&quot;], [2, &quot;a&quot;], [1, &quot;m&quot;], [4, &quot;i&quot;], [5, &quot;c&quot;]])
sampleBST
</code></pre>
<p>However, the above <code>searchAttempt</code> lens constructor does not maintain the BST
structure when values are being removed:</p>
<pre><code class="hljs lang-js">L.remove(valueOfAttempt(3), sampleBST)
</code></pre>
<p>How do we fix this?  We could check and transform the data structure to a BST
after changes.  The <a href="#L-rewrite"><code>L.rewrite</code></a> combinator can be used for that
purpose.  Here is a naïve rewrite to fix a tree after value removal:</p>
<pre><code class="hljs lang-js">var naiveBST = L.rewrite(n =&gt; {
  if (undefined !== n.value) return n
  const s = n.smaller, g = n.greater
  if (!s) return g
  if (!g) return s
  return L.set(search(s.key), s, g)
})
</code></pre>
<p>Here is a working <code>search</code> lens and a <code>valueOf</code> lens constructor:</p>
<pre><code class="hljs lang-js">var search = key =&gt; L.lazy(rec =&gt; {
  const smaller = [&quot;smaller&quot;, rec]
  const greater = [&quot;greater&quot;, rec]
  const found = L.defaults({key})
  return [naiveBST, L.choose(n =&gt; {
    if (!n || key === n.key)
      return found
    return key &lt; n.key ? smaller : greater
  })]
})

var valueOf = key =&gt; [search(key), &quot;value&quot;]
</code></pre>
<p>Now we can also remove values from a binary tree:</p>
<pre><code class="hljs lang-js">L.remove(valueOf(3), sampleBST)
</code></pre>
<p>As an exercise, you could improve the rewrite to better maintain balance.
Perhaps you might even enhance it to maintain a balance condition such
as <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>
or <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black</a>.  Another
worthy exercise would be to make it so that the empty binary tree is <code>null</code>
rather than <code>undefined</code>.</p>
<h4 id="bst-traversal">BST traversal</h4>
<p>What about <a href="#traverals">traversals</a> over BSTs?  We can use
the <a href="#L-branch"><code>L.branch</code></a> combinator to define an in-order traversal over the
values of a BST:</p>
<pre><code class="hljs lang-js">var values = L.lazy(rec =&gt; [
  L.optional,
  naiveBST,
  L.branch({smaller: rec,
            value: L.identity,
            greater: rec})])
</code></pre>
<p>Given a binary tree <code>sampleBST</code> we can now manipulate it as a whole.  For
example:</p>
<pre><code class="hljs lang-js">var Concat = {empty: () =&gt; &quot;&quot;, concat: R.concat}
L.concatAs(R.toUpper, Concat, values, sampleBST)
</code></pre>
<pre><code class="hljs lang-js">L.modify(values, R.toUpper, sampleBST)
</code></pre>
<pre><code class="hljs lang-js">L.remove([values, L.when(x =&gt; x &gt; &quot;e&quot;)], sampleBST)
</code></pre>
<h3 id="-a-id-interfacing-a-interfacing-with-immutable-js"><a id="interfacing"></a> Interfacing with Immutable.js</h3>
<p><a href="http://facebook.github.io/immutable-js/">Immutable.js</a> is a popular library
providing immutable data structures.  As argued
in
<a href="https://medium.com/@drboolean/lenses-with-immutable-js-9bda85674780#.kzq41xgw3">Lenses with Immutable.js</a> it
can be useful to wrap such libraries as <a href="#optics">optics</a>.</p>
<p>When interfacing external libraries with partial lenses one does need to
consider whether and how to support partiality.  Partial lenses allow one to
insert new and remove existing elements rather than just view and update
existing elements.</p>
<h4 id="-list-indexing"><code>List</code> indexing</h4>
<p>Here is a primitive partial lens for
indexing <a href="http://facebook.github.io/immutable-js/docs/#/List"><code>List</code></a> written
using <a href="#L-lens"><code>L.lens</code></a>:</p>
<pre><code class="hljs lang-js">var getList = i =&gt; xs =&gt; Immutable.List.isList(xs) ? xs.get(i) : undefined

var setList = i =&gt; (x, xs) =&gt; {
  if (!Immutable.List.isList(xs))
    xs = Immutable.List()
  if (x !== undefined)
    return xs.set(i, x)
  xs = xs.delete(i)
  return xs.size ? xs : undefined
}

var idxList = i =&gt; L.lens(getList(i), setList(i))
</code></pre>
<p>Note how the above uses <code>isList</code> to check the input.  When viewing, in case the
input is not a <code>List</code>, the proper result is <code>undefined</code>.  When updating the
proper way to handle a non-<code>List</code> is to treat it as empty and also to replace a
resulting empty list with <code>undefined</code>.  Also, when updating, we treat
<code>undefined</code> as a request to <code>delete</code> rather than <code>set</code>.</p>
<p>We can now view existing elements:</p>
<pre><code class="hljs lang-js">var sampleList = Immutable.List([&quot;a&quot;, &quot;l&quot;, &quot;i&quot;, &quot;s&quot;, &quot;t&quot;])
L.get(idxList(2), sampleList)
</code></pre>
<p>Update existing elements:</p>
<pre><code class="hljs lang-js">L.modify(idxList(1), R.toUpper, sampleList)
</code></pre>
<p>Remove existing elements:</p>
<pre><code class="hljs lang-js">L.remove(idxList(0), sampleList)
</code></pre>
<p>And removing the last element propagates removal:</p>
<pre><code class="hljs lang-js">L.remove([&quot;elems&quot;, idxList(0)],
         {elems: Immutable.List([&quot;x&quot;]), look: &quot;No elems!&quot;})
</code></pre>
<p>We can also create lists from non-lists:</p>
<pre><code class="hljs lang-js">L.set(idxList(0), &quot;x&quot;, undefined)
</code></pre>
<p>And we can also append new elements:</p>
<pre><code class="hljs lang-js">L.set(idxList(5), &quot;!&quot;, sampleList)
</code></pre>
<p>Consider what happens when the index given to <code>idxList</code> points further beyond
the last element.  Both the <a href="#L-index"><code>L.index</code></a> lens and the above lens add
<code>undefined</code> values, which is not ideal with partial lenses, because of the
special treatment of <code>undefined</code>.  In practise, however, it is not typical to
<code>set</code> elements except to append just after the last element.</p>
<h4 id="interfacing-traversals">Interfacing traversals</h4>
<p>Fortunately we do not need Immutable.js data structures to provide a compatible
<em>partial</em>
<a href="https://github.com/rpominov/static-land/blob/master/docs/spec.md#traversable"><code>traverse</code></a> function
to support <a href="#traversals">traversals</a>, because it is also possible to implement
traversals simply by providing suitable isomorphisms between Immutable.js data
structures and JSON.  Here is a partial <a href="#isomorphisms">isomorphism</a> between
<code>List</code> and arrays:</p>
<pre><code class="hljs lang-js">var fromList = xs =&gt; Immutable.List.isList(xs) ? xs.toArray() : undefined
var toList = xs =&gt; R.is(Array, xs) &amp;&amp; xs.length ? Immutable.List(xs) : undefined
var isoList = L.iso(fromList, toList)
</code></pre>
<p>So, now we can <a href="#L-compose">compose</a> a traversal over <code>List</code> as:</p>
<pre><code class="hljs lang-js">var seqList = [isoList, L.elems]
</code></pre>
<p>And all the usual operations work as one would expect, for example:</p>
<pre><code class="hljs lang-js">L.remove([seqList, L.when(c =&gt; c &lt; &quot;i&quot;)], sampleList)
</code></pre>
<p>And:</p>
<pre><code class="hljs lang-js">L.concatAs(R.toUpper,
           Concat,
           [seqList, L.when(c =&gt; c &lt;= &quot;i&quot;)],
           sampleList)
</code></pre>
<h2 id="background">Background</h2>
<h3 id="motivation">Motivation</h3>
<p>Consider the following REPL session using Ramda:</p>
<pre><code class="hljs lang-js">R.set(R.lensPath([&quot;x&quot;, &quot;y&quot;]), 1, {})
</code></pre>
<pre><code class="hljs lang-js">R.set(R.compose(R.lensProp(&quot;x&quot;), R.lensProp(&quot;y&quot;)), 1, {})
</code></pre>
<pre><code class="hljs lang-js">R.view(R.lensPath([&quot;x&quot;, &quot;y&quot;]), {})
</code></pre>
<pre><code class="hljs lang-js">R.view(R.compose(R.lensProp(&quot;x&quot;), R.lensProp(&quot;y&quot;)), {})
</code></pre>
<pre><code class="hljs lang-js">R.set(R.lensPath([&quot;x&quot;, &quot;y&quot;]), undefined, {x: {y: 1}})
</code></pre>
<pre><code class="hljs lang-js">R.set(R.compose(R.lensProp(&quot;x&quot;), R.lensProp(&quot;y&quot;)), undefined, {x: {y: 1}})
</code></pre>
<p>One might assume that <a href="http://ramdajs.com/docs/#lensPath"><code>R.lensPath([p0,
...ps])</code></a> is equivalent to
<code>R.compose(R.lensProp(p0), ...ps.map(R.lensProp))</code>, but that is not the case.</p>
<p>With partial lenses you can robustly compose a path lens from prop
lenses <a href="#L-compose"><code>L.compose(L.prop(p0), ...ps.map(L.prop))</code></a> or just use the
shorthand notation <a href="#L-compose"><code>[p0, ...ps]</code></a>.  In JavaScript, missing (and
mismatching) data can be mapped to <code>undefined</code>, which is what partial lenses
also do, because <code>undefined</code> is not a valid <a href="http://json.org/">JSON</a> value.
When a part of a data structure is missing, an attempt to view it returns
<code>undefined</code>.  When a part is missing, setting it to a defined value inserts the
new part.  Setting an existing part to <code>undefined</code> removes it.</p>
<h3 id="design-choices">Design choices</h3>
<p>There are several lens and optics libraries for JavaScript.  In this section I&#39;d
like to very briefly elaborate on a number design choices made during the course
of developing this library.</p>
<h4 id="partiality">Partiality</h4>
<p>Making all optics partial allows optics to not only view and update existing
elements, but also to insert, replace (as in replace with data of different
type) and remove elements and to do so in a seamless and efficient way.  In a
library based on total lenses, one needs to e.g. explicitly compose lenses with
prisms to deal with partiality.  This not only makes the optic compositions more
complex, but can also have a significant negative effect on performance.</p>
<p>The downside of implicit partiality is the potential to create incorrect optics
that signal errors later than when using total optics.</p>
<h4 id="focus-on-json">Focus on JSON</h4>
<p>JSON is the data-interchange format of choice today.  By being able to
effectively and efficiently manipulate JSON data structures directly, one can
avoid using special internal representations of data and make things simpler
(e.g. no need to convert from JSON to efficient immutable collections and back).</p>
<h4 id="use-of-undefined-">Use of <code>undefined</code></h4>
<p><code>undefined</code> is a natural choice in JavaScript, especially when dealing with
JSON, to represent nothingness.  Some libraries use <code>null</code>, but that is arguably
a poor choice, because <code>null</code> is a valid JSON value.  Some libraries implement
special <code>Maybe</code> types, but the benefits do not seem worth the trouble.  First of
all, <code>undefined</code> already exists in JavaScript and is not a valid JSON value.
Inventing a new value to represent nothingness doesn&#39;t seem to add much.  OTOH,
wrapping values with <code>Just</code> objects introduces a significant performance
overhead due to extra allocations.  Operations with optics do not otherwise
necessarily require large numbers of allocations and can be made highly
efficient.</p>
<p>Not having an explicit <code>Just</code> object means that dealing with values such as
<code>Just Nothing</code> requires special consideration.</p>
<h4 id="allowing-strings-l-prop-and-integers-l-index-as-optics">Allowing <a href="#L-prop">strings</a> and <a href="#L-index">integers</a> as optics</h4>
<p>Aside from the brevity, allowing strings and non-negative integers to be
directly used as optics allows one to avoid allocating closures for such optics.
This can provide significant time and, more importantly, space savings in
applications that create large numbers of lenses to address elements in data
structures.</p>
<p>The downside of allowing such special values as optics is that the internal
implementation needs to be careful to deal with them at any point a user given
value needs to be interpreted as an optic.</p>
<h4 id="treating-an-array-of-optics-as-a-composition-l-compose-of-optics">Treating an <a href="#L-compose">array of optics as a composition</a> of optics</h4>
<p>Aside from the brevity, treating an array of optics as a composition allows the
library to be optimized to deal with simple paths highly efficiently and
eliminate the need for separate primitives
like <a href="http://ramdajs.com/docs/#assocPath"><code>assocPath</code></a>
and <a href="http://ramdajs.com/docs/#dissocPath"><code>dissocPath</code></a> for performance reasons.
Client code can also manipulate such simple paths as data.</p>
<h4 id="applicatives">Applicatives</h4>
<p>One interesting consequence of partiality is that it becomes possible
to <a href="#isomorphisms">invert isomorphisms</a> without explicitly making it possible to
extract the forward and backward functions from an isomorphism.  A simple
internal implementation based on functors and applicatives seems to be expressive
enough for a wide variety of operations.</p>
<h4 id="-l-branch-l-branch-"><a href="#L-branch"><code>L.branch</code></a></h4>
<p>By providing combinators for creating new traversals, lenses and isomorphisms,
client code need not depend on the internal implementation of optics.  The
current version of this library exposes the internal implementation
via <a href="#L-toFunction"><code>L.toFunction</code></a>, but it would not be unreasonable to not
provide such an operation.  Only very few applications need to know the internal
representation of optics.</p>
<h4 id="indexing">Indexing</h4>
<p>Indexing in partial lenses is unnested, very simple and based on the indices and
keys of the underlying data structures.  When indexing was added, it essentially
introduced no performance degradation, but since then a few operations have been
added that do require extra allocations to support indexing.  It is also
possible to compose optics so as to create nested indices or paths, but
currently no combinator is directly provided for that.</p>
<h4 id="static-land">Static Land</h4>
<p>The algebraic structures used in partial lenses follow
the <a href="https://github.com/rpominov/static-land">Static Land</a> specification rather
than the <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land</a>
specification.  Static Land does not require wrapping values in objects, which
translates to a significant performance advantage throughout the library,
because fewer allocations are required.</p>
<h4 id="performance">Performance</h4>
<p>Concern for performance has been a part of the work on partial lenses for some
time.  The basic principles can be summarized in order of importance:</p>
<ul>
<li>Minimize overheads</li>
<li>Micro-optimize for common cases</li>
<li>Avoid stack overflows</li>
<li>Avoid <a href="http://accidentallyquadratic.tumblr.com/">quadratic algorithms</a></li>
<li>Avoid optimizations that require large amounts of code</li>
<li>Run <a href="#benchmarks">benchmarks</a> continuously to detect performance regressions</li>
</ul>
<h3 id="benchmarks">Benchmarks</h3>
<p>Here are a few benchmark results on partial lenses (as <code>L</code> version 9.5.0) and
some roughly equivalent operations using <a href="http://ramdajs.com/">Ramda</a> (as <code>R</code>
version 0.23.0), <a href="https://github.com/ramda/ramda-lens">Ramda Lens</a> (as <code>P</code>
version 0.1.1), and <a href="https://github.com/flunc/optics">Flunc Optics</a> (as <code>O</code>
version 0.0.2).  As always with benchmarks, you should take these numbers with a
pinch of salt and preferably try and measure your actual use cases!</p>
<pre><code class="hljs lang-jsx">   7,526,988/s     1.00x   R.reduceRight(add, 0, xs100)
     450,410/s    16.71x   L.foldr(add, 0, L.elems, xs100)
       4,062/s  1852.95x   O.Fold.foldrOf(O.Traversal.traversed, addC, 0, xs100)

      11,221/s     1.00x   R.reduceRight(add, 0, xs100000)
          56/s   201.49x   L.foldr(add, 0, L.elems, xs100000)
           0/s Infinityx   O.Fold.foldrOf(O.Traversal.traversed, addC, 0, xs100000) -- STACK OVERFLOW

     646,713/s     1.00x   L.foldl(add, 0, L.elems, xs100)
     204,137/s     3.17x   R.reduce(add, 0, xs100)
       2,994/s   215.99x   O.Fold.foldlOf(O.Traversal.traversed, addC, 0, xs100)

   3,527,147/s     1.00x   L.sum(L.elems, xs100)
     524,546/s     6.72x   L.concat(Sum, L.elems, xs100)
     126,979/s    27.78x   R.sum(xs100)
      23,214/s   151.94x   P.sumOf(P.traversed, xs100)
       4,303/s   819.69x   O.Fold.sumOf(O.Traversal.traversed, xs100)

     561,951/s     1.00x   L.maximum(L.elems, xs100)
       3,262/s   172.28x   O.Fold.maximumOf(O.Traversal.traversed, xs100)

     139,464/s     1.00x   L.concat(Sum, [L.elems, L.elems, L.elems], xsss100)
     139,119/s     1.00x   L.sum([L.elems, L.elems, L.elems], xsss100)
       4,559/s    30.59x   P.sumOf(R.compose(P.traversed, P.traversed, P.traversed), xsss100)
         889/s   156.80x   O.Fold.sumOf(R.compose(O.Traversal.traversed, O.Traversal.traversed, O.Traversal.traversed), xsss100)

     260,326/s     1.00x   L.collect(L.elems, xs100)
       3,644/s    71.44x   O.Fold.toListOf(O.Traversal.traversed, xs100)

     110,998/s     1.00x   L.collect([L.elems, L.elems, L.elems], xsss100)
       9,253/s    12.00x   R.chain(R.chain(R.identity), xsss100)
         792/s   140.23x   O.Fold.toListOf(R.compose(O.Traversal.traversed, O.Traversal.traversed, O.Traversal.traversed), xsss100)

      66,477/s     1.00x   R.flatten(xsss100)
      31,028/s     2.14x   L.collect(flatten, xsss100)

  14,452,635/s     1.00x   L.modify(L.elems, inc, xs)
   1,851,257/s     7.81x   R.map(inc, xs)
     429,146/s    33.68x   P.over(P.traversed, inc, xs)
     388,421/s    37.21x   O.Setter.over(O.Traversal.traversed, inc, xs)

     423,561/s     1.00x   L.modify(L.elems, inc, xs1000)
     118,932/s     3.56x   R.map(inc, xs1000)
         399/s  1062.77x   O.Setter.over(O.Traversal.traversed, inc, xs1000) -- QUADRATIC
         370/s  1146.14x   P.over(P.traversed, inc, xs1000) -- QUADRATIC

     155,452/s     1.00x   L.modify([L.elems, L.elems, L.elems], inc, xsss100)
       8,907/s    17.45x   R.map(R.map(R.map(inc)), xsss100)
       3,579/s    43.43x   P.over(R.compose(P.traversed, P.traversed, P.traversed), inc, xsss100)
       2,936/s    52.94x   O.Setter.over(R.compose(O.Traversal.traversed, O.Traversal.traversed, O.Traversal.traversed), inc, xsss100)

  31,374,592/s     1.00x   L.get(1, xs)
   3,907,663/s     8.03x   R.nth(1, xs)
   1,487,764/s    21.09x   R.view(l_1, xs)

  22,807,233/s     1.00x   L.set(1, 0, xs)
   7,044,724/s     3.24x   R.update(1, 0, xs)
     963,954/s    23.66x   R.set(l_1, 0, xs)

  29,085,526/s     1.00x   L.get(&quot;y&quot;, xyz)
  24,856,115/s     1.17x   R.prop(&quot;y&quot;, xyz)
   2,444,091/s    11.90x   R.view(l_y, xyz)

  11,058,022/s     1.00x   L.set(&quot;y&quot;, 0, xyz)
   7,425,401/s     1.49x   R.assoc(&quot;y&quot;, 0, xyz)
   1,360,618/s     8.13x   R.set(l_y, 0, xyz)

  13,694,565/s     1.00x   R.path([0,&quot;x&quot;,0,&quot;y&quot;], axay)
  13,404,788/s     1.02x   L.get([0,&quot;x&quot;,0,&quot;y&quot;], axay)
   2,272,396/s     6.03x   R.view(l_0x0y, axay)
     477,184/s    28.70x   R.view(l_0_x_0_y, axay)

   3,905,127/s     1.00x   L.set([0,&quot;x&quot;,0,&quot;y&quot;], 0, axay)
     847,789/s     4.61x   R.assocPath([0,&quot;x&quot;,0,&quot;y&quot;], 0, axay)
     527,980/s     7.40x   R.set(l_0x0y, 0, axay)
     307,247/s    12.71x   R.set(l_0_x_0_y, 0, axay)

   3,890,894/s     1.00x   L.modify([0,&quot;x&quot;,0,&quot;y&quot;], inc, axay)
     567,956/s     6.85x   R.over(l_0x0y, inc, axay)
     339,361/s    11.47x   R.over(l_0_x_0_y, inc, axay)

  24,285,130/s     1.00x   L.remove(1, xs)
   3,100,672/s     7.83x   R.remove(1, 1, xs)

  11,623,646/s     1.00x   L.remove(&quot;y&quot;, xyz)
   2,664,042/s     4.36x   R.dissoc(&quot;y&quot;, xyz)

  14,618,391/s     1.00x   L.get([&quot;x&quot;,&quot;y&quot;,&quot;z&quot;], xyzn)
  13,164,071/s     1.11x   R.path([&quot;x&quot;,&quot;y&quot;,&quot;z&quot;], xyzn)
   2,319,575/s     6.30x   R.view(l_xyz, xyzn)
     831,855/s    17.57x   R.view(l_x_y_z, xyzn)
     161,823/s    90.34x   O.Getter.view(o_x_y_z, xyzn)

   4,646,799/s     1.00x   L.set([&quot;x&quot;,&quot;y&quot;,&quot;z&quot;], 0, xyzn)
   1,427,192/s     3.26x   R.assocPath([&quot;x&quot;,&quot;y&quot;,&quot;z&quot;], 0, xyzn)
     748,830/s     6.21x   R.set(l_xyz, 0, xyzn)
     536,727/s     8.66x   R.set(l_x_y_z, 0, xyzn)
     196,829/s    23.61x   O.Setter.set(o_x_y_z, 0, xyzn)

   1,042,861/s     1.00x   R.find(x =&gt; x &gt; 3, xs100)
     186,667/s     5.59x   L.firstAs(x =&gt; x &gt; 3 ? x : undefined, L.elems, xs100)
       2,757/s   378.23x   O.Fold.findOf(O.Traversal.traversed, x =&gt; x &gt; 3, xs100)

   4,777,497/s     1.00x   L.firstAs(x =&gt; x &lt; 3 ? x : undefined, L.elems, xs100)
   3,736,486/s     1.28x   R.find(x =&gt; x &lt; 3, xs100)
       2,881/s  1658.42x   O.Fold.findOf(O.Traversal.traversed, x =&gt; x &lt; 3, xs100) -- NO SHORTCUT EVALUATION

   4,073,079/s     1.00x   L.remove(50, xs100)
   1,824,964/s     2.23x   R.remove(50, 1, xs100)

   4,309,022/s     1.00x   L.set(50, 2, xs100)
   1,699,553/s     2.54x   R.update(50, 2, xs100)
     581,664/s     7.41x   R.set(l_50, 2, xs100)
</code></pre>
<p>Various operations on <em>partial lenses have been optimized for common cases</em>, but
there is definitely a lot of room for improvement.  The goal is to make partial
lenses fast enough that performance isn&#39;t the reason why you might not want to
use them.</p>
<p>See <a href="https://github.com/calmm-js/partial.lenses/blob/master/bench/bench.js">bench.js</a> for details.</p>
<h3 id="lenses-all-the-way">Lenses all the way</h3>
<p>As said in the first sentence of this document, lenses are convenient for
performing updates on individual elements of immutable data structures.  Having
abilities such
as <a href="#L-compose">nesting</a>, <a href="#L-choose">adapting</a>, <a href="#L-lazy">recursing</a>
and <a href="#L-pick">restructuring</a> using lenses makes the notion of an individual
element quite flexible and, even further, <a href="#traversals">traversals</a> make it
possible to <a href="#L-when">selectively</a> target zero or more elements
of <a href="#L-branch">non-trivial</a> data structures in a single operation.  It can be
tempting to try to do everything with lenses, but that will likely only lead to
misery.  It is important to understand that lenses are just one of many
functional abstractions for working with data structures and sometimes other
approaches can lead to simpler or easier
solutions.  <a href="https://github.com/polytypic/fastener">Zippers</a>, for example, are,
in some ways, less principled and can implement queries and transforms that are
outside the scope of lenses and traversals.</p>
<p>One type of use case which we&#39;ve ran into multiple times and falls out of the
sweet spot of lenses is performing uniform transforms over data structures.  For
example, we&#39;ve run into the following use cases:</p>
<ul>
<li>Eliminate all references to an object with a particular id.</li>
<li>Transform all instances of certain objects over many paths.</li>
<li>Filter out extra fields from objects of varying shapes and paths.</li>
</ul>
<p>One approach to making such whole data structure spanning updates is to use a
simple bottom-up transform.  Here is a simple implementation for JSON based on
ideas from the <a href="https://github.com/ndmitchell/uniplate">Uniplate</a> library:</p>
<pre><code class="hljs lang-js">var descend = (w2w, w) =&gt; R.is(Object, w) ? R.map(w2w, w) : w
var substUp = (h2h, w) =&gt; descend(h2h, descend(w =&gt; substUp(h2h, w), w))
var transform = (w2w, w) =&gt; w2w(substUp(w2w, w))
</code></pre>
<p><code>transform(w2w, w)</code> basically just performs a single-pass bottom-up transform
using the given function <code>w2w</code> over the given data structure <code>w</code>.  Suppose we
are given the following data:</p>
<pre><code class="hljs lang-js">var sampleBloated = {
  just: &quot;some&quot;,
  extra: &quot;crap&quot;,
  that: [
    &quot;we&quot;,
    {want: &quot;to&quot;,
     filter: [&quot;out&quot;],
     including: {the: &quot;following&quot;,
                 extra: true,
                 fields: 1}}]
}
</code></pre>
<p>We can now remove the <code>extra</code> <code>fields</code> like this:</p>
<pre><code class="hljs lang-js">transform(R.ifElse(R.allPass([R.is(Object), R.complement(R.is(Array))]),
                   L.remove(L.props(&quot;extra&quot;, &quot;fields&quot;)),
                   R.identity),
          sampleBloated)
</code></pre>
<h2 id="related-work">Related work</h2>
<p>Lenses are an old concept and there are dozens of academic papers on lenses and
dozens of lens libraries for various languages.  Here are just a few links:</p>
<ul>
<li><a href="http://r6.ca/blog/20120623T104901Z.html">Polymorphic Update with van Laarhoven Lenses</a></li>
<li><a href="http://sebfisch.github.io/research/pub/Fischer+MPC15.pdf">A clear picture of lens laws</a></li>
<li><a href="https://github.com/ramda/ramda-lens">ramda/ramda-lens</a></li>
<li><a href="https://github.com/ekmett/lens">ekmett/lens</a></li>
<li><a href="https://github.com/julien-truffaut/Monocle">julien-truffaut/Monocle</a></li>
<li><a href="https://github.com/xyncro/aether">xyncro/aether</a></li>
<li><a href="https://github.com/flunc/optics">Flunc Optics</a></li>
</ul>
<p>Feel free to suggest more links!</p>

    <div class="loading-hidden">
      <pre><code class="hljs lang-js">document.querySelector('.loading-message').className = "loading-hidden"
ga && ga('send', 'event', 'completed', 'load', Math.round((Date.now() - startTime)/1000))
      </code></pre>
    </div>
  </body>
</html>